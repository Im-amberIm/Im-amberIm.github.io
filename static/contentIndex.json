{"Books/index":{"slug":"Books/index","filePath":"Books/_index.md","title":"Books","links":[],"tags":[],"content":"독서 노트 📚\n읽고 배운 내용을 정리하는 공간입니다."},"My-Garden/Buddings/index":{"slug":"My-Garden/Buddings/index","filePath":"My-Garden/Buddings/_index.md","title":"🌿 Buddings","links":[],"tags":[],"content":"성장 단계의 생각들 (Buddings) 🌿\n\n\n                  \n                  성장하는 문서 \n                  \n                \n\n이 공간의 글들은 지속적으로 발전하고 있습니다. 완성되지 않은 생각들이 자라나는 과정을 담고 있습니다.\n\n"},"My-Garden/Evergreens/index":{"slug":"My-Garden/Evergreens/index","filePath":"My-Garden/Evergreens/_index.md","title":"🌳 Evergreens","links":[],"tags":[],"content":"완성된 생각들 (Evergreens) 🌳\n\n\n                  \n                  완성된 문서 \n                  \n                \n\n이 공간의 글들은 충분한 고민과 발전을 거쳐 정리된 것들입니다. 하지만 여전히 새로운 인사이트가 더해질 수 있습니다.\n\n"},"My-Garden/Seedlings/index":{"slug":"My-Garden/Seedlings/index","filePath":"My-Garden/Seedlings/_index.md","title":"🌱 Seedlings","links":[],"tags":[],"content":"초기 생각들 (Seedlings) 🌱\n\n\n                  \n                  이 문서는 초기 단계의 아이디어입니다 \n                  \n                \n\n아직 정리되지 않은 생각들이나 궁금한 질문들을 담고 있습니다.\n\n"},"My-Garden/Seedlings/avoid-svg-in-js":{"slug":"My-Garden/Seedlings/avoid-svg-in-js","filePath":"My-Garden/Seedlings/avoid-svg-in-js.md","title":"svg-in-js 피해야 하는 이유","links":["SVG-아이콘-최적화-시키기-(feat.-sprite)"],"tags":["seedling","SVG","optimasation","fontend","웹성능"],"content":"svg-in-js 피해야 하는 이유\n💡 발견\n\n배경\n\nNext에서 &lt;Image&gt;이미지 태그로 사용한 svg를 동적으로 색상변경을 하고 싶어 검색하다 svgr이나 다른 라이브러리로 svg를 리액트에서 컴포넌트화해\n쉽게 사용할수 있는걸 보았다.\n(예시)\n// HeartIcon.svg 파일을 React 컴포넌트로 가져옴\nimport HeartIcon from &quot;./HeartIcon.svg&quot;\nconst App = () =&gt; &lt;HeartIcon fill=&quot;red&quot; /&gt;\n그러나 리서치 도중, 이렇게 SVG를 컴포넌트로 사용할 경우 자바스크립트 소스 코드내 포함되어 JS 번들 크기를 키운다는 글을 보았다.\n이렇게 사용하면 개발자는 편하지만, JavaScript 번들 크기 증가, 파싱 및 컴파일 오버헤드, 메모리 사양 증가 등으로 사용자를 불편하게 하는 방식인 것이다.\n🔍 Research 문제 분석\n1. SVG-in-JS의 주요 문제점!\n\nJavaScript 파싱 및 컴파일은 무료가 아님 - 번들 크기가 클수록 JavaScript 엔진이 소스 코드를 처리하는 시간이 길어짐\n성능 테스트에서 6KB 크기의 SVG 아이콘이 JavaScript 번들로 변환될 때 약 24KB로 크기가 증가\n바이트 단위로, JavaScript는 동일한 크기의 이미지나 웹 폰트보다 브라우저가 처리하는 데 더 많은 비용이 듬\n고성능 장치에서는 그 차이가 분명하지 않을 수 있지만, 전 세계 사용자의 75%는 Samsung Galaxy A50이나 Nokia G11과 같은 중저가 기기를 사용\n웹 개발은 모든 사용자에게 포용적이어야 함 - 부유한 지역의 사용자만을 위한 것이 아님\nSVG는 JavaScript가 아니라 이미지를 설명하는 HTML과 유사한 XML 태그로, JS 번들에서 분리하여 파싱 및 컴파일 단계에서 제외해야 함\n\n그럼 어떻게 JS 크기를 증가시키지?\nJavaScript 번들: JavaScript 번들은 React 애플리케이션의 JavaScript 코드, CSS (CSS-in-JS 라이브러리 사용 시), 그리고 빌드 과정에서 처리된 이미지 등의 자산을 포함한다.\nJSX는 HTML의 확장된 문법이기 때문에 트랜스파일 될때 JS 코드로 변환된다. 이때 React.createElement함수 호출 형태로 변화된다.\n// 컴포넌트에 그대로 사용한 svg는\nconst MySVG = () =&gt; (\n  &lt;svg width=&quot;100&quot; height=&quot;100&quot; xmlns=&quot;www.w3.org/2000/svg&quot;&gt;\n    {&quot; &quot;}\n    &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot; strokeWidth=&quot;3&quot; fill=&quot;blue&quot; /&gt;{&quot; &quot;}\n  &lt;/svg&gt;\n)\n// 이렇게 JS로 변환됨\nconst MySVG = () =&gt;\n  React.createElement(\n    &quot;svg&quot;,\n    { width: &quot;100&quot;, height: &quot;100&quot;, xmlns: &quot;www.w3.org/2000/svg&quot; },\n    React.createElement(&quot;circle&quot;, {\n      cx: &quot;50&quot;,\n      cy: &quot;50&quot;,\n      r: &quot;40&quot;,\n      stroke: &quot;black&quot;,\n      strokeWidth: &quot;3&quot;,\n      fill: &quot;blue&quot;,\n    }),\n  )\n이 모든 SVG가 JS 번들에 포함되기 때문에 사이즈가 증가되 성능을 저하시킨다\n2. 대체 SVG 처리 방식 비교\n1. Image + SVG 방식: &lt;img src=&#039;icon.svg&#039;&gt;\n\n장점: 브라우저 캐싱 활용, HTTP/2에서 효율적 로딩, JS 번들 크기에 영향 없음\n단점: CSS로 내부 스타일링 어려움, 동적 색상 변경 제한적, 각 아이콘마다 HTTP 요청 필요\n성능 데이터: Cloud Four의 테스트에서 300개 아이콘 렌더링 시 가장 빠른 로드 시간을 보임\n\n2. SVG in CSS 방식: CSS 속성을 사용하여 SVG 삽입\nbackground-image / mask-image 속성 사용 (Data URI) + root에서 SVG 변수화해 사용.\n \n:root {\n  --icon-heart: url(&quot;data:image/svg+xml,%3Csvg viewBox=&#039;0 0 24 24&#039; fill=&#039;currentColor&#039;%3E%3Cpath d=&#039;M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z&#039;/%3E%3C/svg%3E&quot;);\n}\n \n.heart-icon {\n  display: inline-block;\n  width: 24px;\n  height: 24px;\n  background-image: var(--icon-heart);\n  background-repeat: no-repeat;\n  background-size: contain;\n}\n \n\n장점: HTTP 요청 감소 (data URI 사용 시), CSS 스타일링 용이 (background-color, mask-image 등 활용), JS 번들 크기 감소 가능성\n단점: data URI 인코딩 필요, 복잡한 SVG 내부 스타일링 제한, 브라우저 지원 고려 필요\n성능 데이터: 아이콘 개수와 스타일에 따라 성능이 달라질 수 있음\n\n3. SVG 스프라이트 방식: &lt;use&gt; 태그로 외부 스프라이트 참조\n\n장점: 한 번의 HTTP 요청으로 모든 아이콘 로드, JS 번들 크기에 영향 크게 없음, CSS 스타일링 가능, 브라우저 캐싱 활용 가능\n결론: 성능과 유연성 모두에서 최적의 방식\n성능 데이터: 많은 아이콘을 사용할 때 메모리 사용량과 렌더링 성능 면에서 가장 효율적\n\nSVG-in-CSS vs SVG Sprite\n\n고려 사항 우선순위: 동적 변경 가능 &amp;&amp; 한번 로드된 SVG 파일로 재사용 가능 (캐싱) &amp;&amp; 재사용성 (컴포넌트화 용이 포함)\n\nSVG in CSS도 방식도 css 파일이 브라우저에 캐싱되서 효율적이고 JS 번들 사이즈를 최적화 시켜주지만, 아래와 같은 우려사항이 있다.\n\n무의미한 &lt;span&gt;을 사용해야함. &lt;svg&gt;가 더 의미론적임 (벡터 그래픽 콘텐츠로 명확하게 인식)\nSVG를 다 root변수로 정의하면 css 파일이 커저 CSSOM 크기 증가 우려. (메로리 사용량 증가)\ndata URI 형태로 인코딩 하는 과정이 오버헤드 일수 있음\n\n채택한 방식: SVG Sprite 방식 🎉\n이 방법은 옛날 이미지를 스프라이트 해서 쓰던 방식과 유사하다.\n한 SVG Sprite 파일에 프로젝트에서 사용되는 모든 SVG를 &lt;symbol&gt; 사용해 병합한다. 이는 HTTP 요청을 한번만 요구하고 ,&lt;use&gt;을 사용해서 부분적으로 참조해서 사용하는 방식이다.\n이 방식은 img 태그를 사용했을때의 최적화 장점 포함, 동적으로 JS 없이 css 스타일도 적용할 수 있다.\n적용 방법\n\n외부 스프라이트 파일 : &lt;symbol&gt;과 id를 사용해 모든 SVG파일을 병합\n\n// icon-sprite.svg\n \n&lt;svg xmlns=&quot;www.w3.org/2000/svg&quot;&gt;\n \n // id로 각 아이콘 이름 부여해 구별\n  &lt;symbol id=&quot;icon-heart&quot; viewBox=&quot;0 0 24 24&quot;&gt;\n    &lt;path fill=&quot;currentColor&quot; d=&quot;M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z&quot;/&gt;\n  &lt;/symbol&gt;\n  &lt;symbol id=&quot;icon-star&quot; viewBox=&quot;0 0 24 24&quot;&gt;\n    &lt;path fill=&quot;currentColor&quot; d=&quot;M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z&quot;/&gt;\n  &lt;/symbol&gt;\n  &lt;!-- 다른 아이콘들 --&gt;\n&lt;/svg&gt;\n&lt;use&gt;사용해 스프라이트 파일에서 svg 심볼 참조:\n&lt;svg width=&quot;24&quot; height=&quot;24&quot;&gt;\n  &lt;use href=&quot;/assets/icons.svg#icon-heart&quot;&gt;&lt;/use&gt;\n&lt;/svg&gt;\n아이콘 재사용성 위해 &lt;Svg&gt; 로 컴포넌트화\nexport default function Svg({ name, type, prefix }) {\n  return (\n    &lt;svg aria-label={name}&gt;\n      // name으로 id 참조\n      &lt;use href={`/assets/${type}s_sprite.svg/#${prefix}_${name}`} /&gt;\n    &lt;/svg&gt;\n  )\n}\n잠깐, 잠깐 ☝️ JSX로 컴포넌트화해서 사용하면 결국 JS번들에 포함 되는거 아니야??\n맞다. &lt;svg&gt; + &lt;use&gt;를 컴포넌트화 해서 작성한 코드는 JS 코드로 변환되 번들에 포함된다.\n그러나 &lt;svg&gt;, &lt;use&gt; 요소만 변환되고 use가 참조하는 SVG 외부 스프라이트 시트에서 가져오기 때문에 SVG의 그 모든 path와 속성이 번들에 추가가 안되는것만 으로도 번들 크기를 줄이는데 효과적이다.\n그리고 외부 SVG 파일은 브라우저에 캐싱되기떄문에 동일안 아이콘을 써도 HTTP 요청을 한번만 한다.\n그리고, JSX에서 SVG를 직접 넣었을 때 번들이 더 커지고 컴포넌트를 사용할때마다 JS 번들에 포함되 코드 중복으로 번들 사이즈가 커진다.\n🚩 알게된 것\n1. svg 동적 스타일링 기법\nCSS 변수를 활용한 동적 스타일링:\n/* 스프라이트 파일 내 SVG 요소 */\n&lt;path fill=&quot;var(--icon-fill, currentColor)&quot; stroke=&quot;var(--icon-stroke, none)&quot; /&gt;\n \n/* 사용 시 CSS */\n.active-icon {\n  --icon-fill: #ff0000;\n}\n.inactive-icon {\n  --icon-fill: #cccccc;\n}\n2. SVG 스프라이트 생성 도구\n자동화 도구:\n\nsvg-sprite: 명령줄 도구로, SVG 파일을 스프라이트로 변환 (+ 후에 사용해보았으나 내 마음대로 커스텀 하기 힘들었음)\nsvg-sprite-loader: Webpack 로더로, 빌드 프로세스에 통합\nSVGO: SVG 최적화 도구, 파일 크기를 크게 줄여줌 (+ 이것도 딱히 최적화 할게 없었는지 변경후 차이가 없었음. 기본 아이콘이라 그런것 같음)\n\n3. 각 기법 성능 테스트\n🔗 해당 아티클 부분\n🔗 직접 테스트 해볼수 있는 곳\n아티클 내 진행한 성능 테스트 결과:\n\n\n렌더링 시간:\n\n50개 아이콘: 스프라이트 방식이 SVG-in-JS보다 30% 빠름\n300개 아이콘: 스프라이트 방식이 SVG-in-JS보다 최대 4배 빠름\n\n\n\n메모리 사용량:\n\nSVG-in-JS: 높은 메모리 사용량 (300개 아이콘에서 약 8MB 추가 사용)\n스프라이트: 낮은 메모리 사용량 (300개 아이콘에서 약 2MB 추가 사용)\n\n\n\n초기 로드 시간:\n\nSVG-in-JS: 번들 크기 증가로 초기 로드 느림\n이미지: 각 이미지마다 HTTP 요청 필요\n스프라이트: 단일 HTTP 요청, 캐싱 효과적\n\n\n\n5. 실제 프로젝트 적용 시 고려사항\n\n\n기존 프로젝트 마이그레이션:\n\n점진적으로 변경 (필요한 부분부터 스프라이트 방식 적용)\n기존 SVG 컴포넌트를 스프라이트 버전으로 대체하는 어댑터 패턴 고려\n\n\n\n디자인 시스템 통합:\n\n아이콘 네이밍 규칙 표준화 (이 부분은 이미 svg 컨밴션을 이용해 Image src에 넣을 path를 객체로 생성하는 스크립트 사용해서 되어있음)\n동적 스타일링을 위한 CSS 변수 시스템 구축\n스프라이트 자동 생성 빌드 파이프라인 구축\n\n\n\n브라우저 지원 고려:\n\n외부 SVG 파일 참조는 IE에서 제한적 지원\n크로스 오리진 이슈는 CORS 설정 필요\nCSS Mask 방식은 브라우저 지원 범위 확인 필요\n\n\n\n+추가 (2025)\n@svg-use 라이브러리\n작년말에 릴리즈된 @svg-use 라이브러리 발견.\n내가 스크립트 짜면서 하려던 스프라이트 접근 방식의 장점을 유지하면서도 React 컴포넌트처럼 사용할 수 있는 방법을 쓸 수 있는 라이브러리가 있네;\n(내가 작년에 개발중일때와 겹쳐서 아마 초기단계거나 아직 안나왔었을거라 믿고싶다…🥹)\n그래도 직접 짜보면서 공부 했으니 오히려 좋아!\n// npm install @svg-use\n \nimport { useSVG } from &quot;@svg-use&quot;\n \nfunction App() {\n  return &lt;div&gt;{useSVG(&quot;/sprites.svg#icon-heart&quot;, { fill: &quot;red&quot; })}&lt;/div&gt;\n}\n⏭ 다음 단계 (What’s Next?)\n\n 현재 프로젝트의 SVG 아이콘 분석 (수, 크기, 사용 패턴)\n SVG 스프라이트 자동 생성 스크립트 작성\n SVG 스프라이트 컴포넌트 설계 (동적 스타일링 지원)\n 성능 테스트 수행 (변경 전/후 비교)\n\n📚 References &amp; Resources\n\nBreaking Up with SVG-in-JS in 2023 (2023) by Extrem, K. - Kurt Extrem의 SVG-in-JS 문제점 및 대안 분석\n2023년 SVG-in-JS와 결별 - Kurt Extrem 글의 한국어 번역\nWhich SVG technique performs best for way too many icons? (2021) by Stika, T.\n다양한 SVG 기법의 성능 비교 테스트\nIntroducing @svg-use (2024) - SVG 스프라이트를 React에서 쉽게 사용할 수 있는 새로운 라이브러리 소개\nSVG Sprite 기법을 사용해 나만의 특별한 Icon 컴포넌트 개발 (2023) - SVG 스프라이트를 활용한 React 컴포넌트 구현 사례\n아이콘으로 SVG 스프라이트를 만드는 방법(2023) - SVG 스프라이트 생성 방법론\n\n📝 연관 노트\n\n실제 적용 ⇒ SVG 아이콘 최적화 시키기 (feat. sprite)\n"},"My-Garden/Seedlings/next-image-optimasation":{"slug":"My-Garden/Seedlings/next-image-optimasation","filePath":"My-Garden/Seedlings/next-image-optimasation.md","title":"Next에서 이미지 최적화 방법","links":["/"],"tags":["seedling","Next"],"content":"\nDoctru 프로젝트에서 Next 프레임워크를 쓰면서 Next가 가진 이미지 최적화 방법을 최대한 쓸 수 있는 법이 있을까?\n\n🔍 Research\n1. Next의 &lt;Image&gt; 컴포넌트 사용\n브라우저의 크기에 따라 이미지를 최적화하여 보여줌\n4000x3000 크기의 이미지를 100x100 크기로 충분하다면?\n자동으로 서버에서 크기를 줄여 100x100 크기의 이미지를 보여줌\n→ 20배의 용량 절약\n엄밀히 말하면 Page Router의 기능은 아니지만, 유용한 최적화 기능임\nLayout Shift 최적화를 위해 width와 height를 꼭 지정해야 함\nlayout shift 사용자 경험에 안좋음(이미지가 로딩중 다른 요소가 그자리에있다가 로딩후 옆 엘리먼트가 밀리는 현상?)\n최적화 해주니까 tinypng 이용해서 최적화 굳이 안해줘도 됨\nimport Image from &quot;next/image&quot;\n \nfunction MyComponent() {\n  return &lt;Image src=&quot;/images/profile.jpg&quot; alt=&quot;Picture of the author&quot; width={500} height={500} /&gt;\n}\nImage 컴포넌트의 특징, 주의사항\n\n크기 최적화: 각 디바이스에 맞는 적절한 크기의 이미지를 자동으로 제공하며, WebP와 AVIF와 같은 최신 이미지 포맷을 사용함\n시각적 안정성: 이미지를 로딩할 때 레이아웃 시프트를 자동으로 방지함\n빠른 페이지 로드: 이미지를 뷰포트에 들어올 때만 로드하며, 선택적으로 블러 업 플레이스홀더를 사용할 수 있음\n자산 유연성: 원격 서버에 저장된 이미지도 필요에 따라 크기를 조정할 수 있음\n\n로컬 이미지 사용\n\nES module 문법으로 static import (import srcImage from ‘./image.png’)를 사용하면 자동으로 크기를 읽어올 수 있음\n로컬 이미지를 사용하려면, .jpg, .png, 또는 .webp 이미지 파일을 public 폴더에서 가져와서 import해야 함. Next.js는 - - 자동으로 이미지의 본래 너비와 높이를 결정하여 Cumulative Layout Shift를 방지함\n\nimport Image from &quot;next/image&quot;\nimport profilePic from &quot;./me.png&quot;\n \nexport default function Page() {\n  return &lt;Image src={profilePic} alt=&quot;Picture of the author&quot; /&gt;\n}\n원격 이미지 사용\n\n\nremote image: 만약 다른 서버의 이미지를 사용한다면, next.config.js의 remotePatterns옵션으로 서버 접근을 허용해야 함 (악용 방지 차원)\nNextJS remotePatters\n\n\n숫자로 크기를 정하기 애매한 경우, layout=“fill” 옵션을 사용하면 부모 요소의 크기에 맞게 이미지를 늘릴 수 있음\n\n\n원격 이미지를 사용할 경우, src 속성에 URL 문자열을 제공해야 함. 이때, width와 height 속성을 수동으로 지정하여 이미지의 비율을 - 유지하고 레이아웃 시프트를 방지함. 원격 서버에서 이미지를 안전하게 사용하기 위해서는 next.config.js에서 지원되는 URL 패턴을 정의해야 함\n\n\nimport Image from &quot;next/image&quot;\n \nexport default function Page() {\n  return (\n    &lt;Image\n      src=&quot;s3.amazonaws.com/my-bucket/profile.png&quot;\n      alt=&quot;Picture of the author&quot;\n      width={500}\n      height={500}\n    /&gt;\n  )\n}\n🚩 알게된 것\n\nNext.js의 Image 컴포넌트는 자동으로 이미지 크기를 최적화해서 성능 향상시킴\n로컬 이미지나 원격 이미지 모두 효율적으로 관리 가능함\n레이아웃 시프트 방지를 위해 width와 height 속성이 중요함\n원격 이미지 사용시 보안을 위해 remotePatterns 설정이 필요함\n\n⏭ 다음 단계 (What’s Next?)\n\n 실제 프로젝트에 Image 컴포넌트 적용해보기\n 다양한 이미지 크기에서 최적화 효과 테스트하기\n 블러 플레이스홀더 옵션 활용해보기\n 반응형 이미지 처리 방법 더 알아보기\n\n📚 References &amp; Resources\n\n올리브영 테크 블로그(2023) : NEXT.JS의 이미지 최적화는 어떻게 동작하는가?\nNext 공식문서: 이미지 최적화\n\n📝 연관 노트\n\n🌿 Budding: \n🌳 Evergreen: \n"},"My-Garden/Seedlings/query-key-factories":{"slug":"My-Garden/Seedlings/query-key-factories","filePath":"My-Garden/Seedlings/query-key-factories.md","title":"QueryKey factory 리서치","links":["Posts/query-key-factories"],"tags":["seedlings","tanstack-query","query-key"],"content":"💡 쿼리키 관리 팁 - QueryKey factory\n\n배경\n\n쿼리키에 params를 포함하면서 페이지를 param별로 캐싱하려니 좀 더 정돈된 쿼리키 사용이 필요했다. 배열이 길어지다 보니 헷갈리기도 하고, 변수로 체계화 시켜서 중앙에서 관리하는 것이 좋을 것 같았다.\n🔍 Research\n관련 예시를 찾던 도중, Tanstack-query를 관리하는 개발자의 블로그(TkDodo)에서 쿼리키 관리 방식에 대한 포스트를 발견했다. 1\n\nTkDodo는 모든 쿼리키를 배열 안의 단일 객체로 표현하는 방식을 권장한다.\n\n\n모든 쿼리키가 정확히 하나의 객체를 포함한 배열로 구성\n객체 내부에 모든 필요한 데이터를 키-값 쌍으로 표현\n\n예: scope: &quot;todos&quot;, entity: &quot;list&quot;, id: 5 등\n\n\n\nTkDodo의 쿼리키 관리 패턴\nconst todoKeys = {\n  // ✅ all keys are arrays with exactly one object\n  // = 모든 키는 한 object를 포함한 배열이다.\n  all: [{ scope: &quot;todos&quot; }] as const,\n  lists: () =&gt; [{ ...todoKeys.all[0], entity: &quot;list&quot; }] as const,\n  list: (state: State, sorting: Sorting) =&gt; [{ ...todoKeys.lists()[0], state, sorting }] as const,\n}\n쿼리키 팩토리 예시\n\n쿼리키들을 배열안에 한 object{key: value}로 사용하는 방식\n\nconst userKeys = {\n  // 1. 기본 스코프 정의\n  all: [{ scope: &quot;users&quot; }] as const,\n \n  // 2. entity: list 구조 생성\n  lists: () =&gt; [{ ...userKeys.all[0], entity: &quot;list&quot; }] as const,\n  list: (filters = {}) =&gt; [{ ...userKeys.lists()[0], ...filters }] as const,\n \n  // 이 후 entity 별로 메서드 추가 (예시: detail)\n  details: () =&gt; [{ ...userKeys.all[0], entity: &quot;detail&quot; }] as const,\n  detail: (userId) =&gt; [{ ...userKeys.details()[0], id: userId }] as const,\n \n  ...\n}\n메서드 간의 계층 구조\n \nuserKeys.all → 기본 도메인 정의\n  ├── userKeys.lists() → 목록 관련 기본 구조\n  │     └── userKeys.list(filters) → 최종 목록 쿼리 (필터 포함)\n  │\n  └── userKeys.details() → 상세 정보 기본 구조\n        └── userKeys.detail(userId) → 특정 사용자 상세 정보\n \n \n메서드 구조 (Domain &gt; Entity &gt; Query)\n1. userKeys.all - 기본 스코프\n\n모든 users 관련 쿼리를 한 번에 무효화할 때 유용\n반환값: [{ scope: &quot;users&quot; }]\n예: queryClient.invalidateQueries({ queryKey: userKeys.all })\n\n2-1. userKeys.lists() - 목록 기본 쿼리키\n\n모든 users의 list(목록) 쿼리키\n모든 list 쿼리(필터와 상관없이)를 무효화할 때 사용\n반환값: [{ scope: &quot;users&quot;, entity: &quot;list&quot; }]\n예: queryClient.invalidateQueries({ queryKey: userKeys.lists() })\n\n2-2. userKeys.list(filters) - 필터가 적용된 list 쿼리키\n\n구체적인 필터가 추가된 list 쿼리키\n특정 필터 조건의 목록 데이터를 조회하거나 무효화할 때 사용\n반환값: [{ scope: &quot;users&quot;, entity: &quot;list&quot;, filters }]\n예: 특정 페이지 목록 조회: useQuery({ queryKey: userKeys.list({ page: 1, limit: 10 }) })\n\n이 방식대로 단일 객체로 관리하면 쿼리를 쉽게 그룹화 할 수 있고, 객체의 properties를 기반으로 부분 일치 검색(deep partial matching)을 더 쉽게 할 수 있다.\nTanstack-query 공식문서2에 따르면 invalidateQueries나 removeQueries 같은 메서드를 사용할 때 deep partial matching 알고리즘을 사용한다. 이 알고리즘은 쿼리키의 prefix(접두사) 기반으로 작동하기 때문에 배열의 첫 부분부터 순서가 일치해야 한다. 즉, 캐시된 퀴리키의 시작부분이 무효화하려는 패턴과 정확히 일치해야 된다.\n그래서 이 같이 한 object에 key: value 형식으로 관리하면 명명된 속성(key)으로 바로 접근 가능하기 때문에 순서와 상관없이 더 정교하게 무효화를 시킬 수 있다.\n첫 번째 요소가 원시값일 때의 한계\n\n배열 prefix를 기반으로 매칭하기 때문에 원시값으로 정의한 쿼리키는 순서가 바뀔시 다른 쿼리로 인식됨 ⚠️\n\nconst getAllUsers = useQuery([&quot;users&quot;])\nconst getUserById = useQuery([&quot;users&quot;, userId])\nconst getUserPosts = useQuery([&quot;users&quot;, userId, &quot;posts&quot;])\nconst getUserFollowers = useQuery([&quot;users&quot;, userId, &quot;followers&quot;])\n \n// getUserPosts 쿼리키와 공집합이지만 순서가 바뀌어 다른 쿼리로 인식됨\nconst userPostsWrong = useQuery([&quot;posts&quot;, userId, &quot;users&quot;])\n쿼리 비교 알고리즘\n\n정확히 어떻게 비교할까?\nTanStack Query의 깃허브 소스 코드\n\n// queryKey 비교 알고리즘 (단순화됨)\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean {\n  return partialDeepEqual(a, b)\n}\n \n// 객체의 부분 일치를 확인하는 함수\nfunction partialDeepEqual(a: any, b: any): boolean {\n  // 1. 두 값이 정확히 같다면 일치\n  if (a === b) {\n    return true\n  }\n \n  // 2. 타입이 다르면 불일치\n  if (typeof a !== typeof b) {\n    return false\n  }\n \n  // 3. 두 값이 모두 객체인 경우\n  if (a &amp;&amp; b &amp;&amp; typeof a === &quot;object&quot; &amp;&amp; typeof b === &quot;object&quot;) {\n    // b의 모든 속성이 a에 존재하고 일치하는지 확인\n    return !Object.keys(b).some((key) =&gt; !partialDeepEqual(a[key], b[key]))\n  }\n \n  return false\n}\n이 비교 알고리즘은 단방향으로 동작한다는걸 이해하는게 중요하다.\nTanStack Query는 캐시의 모든 쿼리키들을 순회하면서 각각에 대해:\n\n무효화 패턴(b)이 저장된 쿼리키(a)의 부분 집합인지 확인한다.\n즉, “b의 모든 속성이 a에도 있고 값이 같은가?”를 검사하는 것이다.\n\n이는 실제 중첩된 쿼리키를 무효화하는데 중요한 특성이다.\n예를 들어, 다음과 같은 쿼리키가 있다고 가정해보자.\n1. 캐시에 있는 쿼리키들\n1. [{ scope: &#039;users&#039;, id: 5, entity: &#039;detail&#039; }]\n2. [{ scope: &#039;users&#039;, id: 5, subEntity: &#039;posts&#039; }]\n3. [{ scope: &#039;users&#039;, id: 7, subEntity: &#039;posts&#039; }]\n4. [{ scope: &#039;posts&#039;, id: 10 }]\n\n2. 무효화 명령을 실행:\nqueryClient.invalidateQueries({\n  queryKey: [{ scope: &quot;users&quot;, id: 5 }],\n})\n3. 결과:\n\n쿼리 1: ✅ 무효화 됨 (패턴의 모든 속성이 포함됨)\n쿼리 2: ✅ 무효화 됨 (패턴의 모든 속성이 포함됨)\n쿼리 3: ❌ 무효화 안됨 (id가 다름)\n쿼리 4: ❌ 무효화 안됨 (scope이 다름)\n\n4. 왜 “단방향”인가?\n\n무효화 패턴(b)이 쿼리키(a)의 부분 집합인지만 확인.\n역방향(쿼리키가 패턴의 부분 집합인지)은 확인하지 않음.\n\n쿼리키 팩토리 사용 예시\n// 🧹 사용자 관련 모든 쿼리 제거\nqueryClient.removeQueries({\n  queryKey: [{ scope: &quot;users&quot; }],\n})\n \n// 🔄 모든 사용자 목록 쿼리 리셋 (필터와 상관없이)\nqueryClient.resetQueries({\n  queryKey: [{ scope: &quot;users&quot;, entity: &quot;list&quot; }],\n})\n \n// ⚡ 특정 사용자의 모든 관련 데이터 무효화\nqueryClient.invalidateQueries({\n  queryKey: [{ scope: &quot;users&quot;, id: userId }],\n})\n \n// 🌐 전체 애플리케이션의 모든 &#039;posts&#039; 서브엔티티 무효화 (스코프 무관)\nqueryClient.invalidateQueries({\n  queryKey: [{ subEntity: &quot;posts&quot; }],\n})\n꼭 첫번째 인덱스에 객체를 둬야 하나?\n굳이 첫번째에 객체가 와야지만 부분 일치 검색이 가능한것은 아니지만, TkDodo는 첫번째 요소를 객체를 고정하면 구조분해를 더 명확하게 할 수 있고 필터링을 더 유연하게 사용할수 있어 첫번째에 두는걸 권장한다.\n이 방식의 장점: 코드 유지보수성, 타입 안전성, 그리고 필터링 기능을 향상\n아래 처럼 구조 분해를 활용하면 쿼리 함수에서 쿼리키의 첫번째 요소가 객체이므로 명명된 속성으로 바로 접근 가능하다.\n(그럼 부분적으로만 객체 사용해도 되는구나)\n// 쿼리 함수에서 구조 분해 활용하기\nconst fetchTodos = async ({\n  // 쿼리키의 첫 번째 요소가 객체이므로 명명된 속성으로 바로 접근 가능\n  queryKey: [{ state, sorting, filters }],\n}: QueryFunctionContext&lt;ReturnType&lt;typeof todoKeys.list&gt;&gt;) =&gt; {\n  // ✅ URL 빌드시 위치가 아닌 속성명으로 접근하므로 안전\n  const response = await axios.get(`todos/${state}?sorting=${sorting}&amp;limit=${filters.limit}`)\n  return response.data\n}\n\n⏭ 다음 단계 (What’s Next?)\n\n 실제 프로젝트 적용 예시 추가해보기\n\n📚 References &amp; Resources\nDorfmeister, D. 2021, “Leveraging the Query Function Context”\n📝 연관 노트\n\n🌳 Evergreen: Query Key 관리하기 - query key factories\n\n\nFootnotes\n\n\n링크:Leveraging the Query Function Context ↩\n\n\n링크:TanStack Query - Query Matching with invalidateQueries ↩\n\n\n"},"My-Garden/Seedlings/retro-view-my-startup":{"slug":"My-Garden/Seedlings/retro-view-my-startup","filePath":"My-Garden/Seedlings/retro-view-my-startup.md","title":"개발 과정 중 직면한 문제 정리","links":[],"tags":["seedling"],"content":"초급 프로젝트 회고록\nWeek 1\n문제: BigInt Type 직렬화\nTypeError: Do not know how to serialize a BigInt 에러 해결\n// 방법 1: prototype 확장\nBigInt.prototype.toJSON = function () {\n  return { $bigint: this.toString() }\n}\n \n// 방법 2: stringify replacer 사용\nfunction bigIntToString(data) {\n  return JSON.stringify(data, (key, value) =&gt;\n    typeof value === &quot;bigint&quot; ? value.toString() : value,\n  )\n}\n \n// 방법 3: map으로 직접 변환 (최종 채택)\nconst bigIntToString = companies.map((company) =&gt; ({\n  ...company,\n  actualInvestment: company.actualInvestment.toString(),\n  revenue: company.revenue.toString(),\n}))\n\nJSON.stringify만 사용시 Content-Type이 ‘text/html’로 설정되는 문제 발견\n해결책으로 map 사용 방식 채택 (가장 직관적이고 효율적)\n필요한 경우 res.setHeader(&quot;Content-Type&quot;, &quot;application/json&quot;) 설정\n\n참고: MDN BigInt JSON, Prisma BigInt\n문제: 테이블 cell에서 ellipsis 적용 안됨\n.TableRow .description {\n  max-width: 301px;\n  width: 100%;\n}\n \n.TableRow .description span {\n  display: -webkit-box;\n  -webkit-box-orient: vertical;\n  -webkit-line-clamp: 2;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: normal;\n}\n\ntd cell에서 직접 line-clamp가 안되어서 span으로 감싸서 해결함\nline-clamp를 사용하기 위해서는 블록 레벨 요소가 필요하므로, 이를 위해 td 내에 span으로 감싸서 -webkit-box 로 문제를 해결함. td는 블록레벨 요소나 -webkit-box같은 레이아웃 모델을 적용할수 없음\nellipsis 적용을 위해 overflow: hidden과 white-space: nowrap 필수\n\n문제: 테이블 border-radius 이슈\n.Table thead tr th:first-child {\n  border-bottom-left-radius: 4px;\n}\n \n.Table thead tr th:last-child {\n  border-bottom-right-radius: 4px;\n}\n \n.Table tbody tr:first-child td:first-child {\n  border-top-left-radius: 4px;\n}\n \n.Table tbody tr:first-child td:last-child {\n  border-top-right-radius: 4px;\n}\n\n태블릿 사이즈에서 첫 컬럼이 display:none 되면서 border-radius가 사라지는 문제 해결\nthead와 tbody 각각에 border-radius 적용하여 해결\n\n참고: 테이블 z-index\n문제: 페이지네이션 방식 선택\n\n디자인은 offset 기반인데 요구사항은 cursor 기반이라 고민\n결론: offset 기반으로 변경\n\ncursor 기반 유지시 서버에서 5페이지치 데이터 미리 조회 필요\n실제 이점이 크지 않아 디자인과의 일관성 선택\n\n\n\nWeek 2-3\n테이블, 드롭다운 버튼, 페이지네이션 공통 컴포넌트화\n고민\n각 테이블마다 필요한 필드가 다르고 렌더방식도 상이함\n해결\n각 필드를 체크해서 필드종류에 따라 유연하게 렌더링 하는 방식으로 접근.\n\n\nTable 컴포넌트\n\n기능: 테이블의 전반적인 구조를 담당하며, list와 tableHeaders를 받아 동적으로 테이블을 생성.\n설계 요소: 데이터 유효성 검사를 통해 리스트가 없거나 잘못된 형식의 데이터를 처리. tableHeaders를 기반으로 thead와 tbody를 생성하여 각 셀은 TableData로 렌더링, 필드별로 다른 스타일과 기능을 지원.\n\n\n\nTableData 컴포넌트\n\n기능: 각 셀의 데이터를 렌더링하며, header와 item을 받아 특정 필드에 따라 적절한 렌더링 수행.\n설계 요소: renderTableData 함수를 사용해 필드별 스타일과 기능을 조건부로 렌더링. 예를 들어, 기업명 필드는 로고와 링크를 표시하고, 투자 금액 필드는 포맷 변환을 적용.\n\n\n\nColGroup 컴포넌트\n\n기능: 테이블 컬럼의 너비를 설정.\n설계 요소: columns를 받아 특정 필드는 고정 너비, 나머지는 공통 너비로 설정하여 일관된 레이아웃 유지.\n\n\n\n개선점: propsType 같은걸로 type check 하는것도 좋아보임.\n아니면 React-table 같은 라이브러리 쓰는것도 좋아보임\n드롭다운 버튼 컴포넌트화\n문제점:\n드롭다운 버튼을 누를 때, 각 버튼에 맞는 정렬된 데이터를 API로부터 Fetch해야 했음. 이 과정에서 다양한 드롭다운 버튼이 존재하는데, 이들을 각각 공통 컴포넌트로 관리하면서도 각기 다른 동작을 수행하도록 구현하는 것이 도전이었음.\n해결책:\n\n테이블 컴포넌트에서 했던 것처럼, 필요한 3개의 버튼을 객체(value, label)로 정의하고, props로 버튼 타입(buttonType), 정렬 기준(orderBy), 정렬 상태 업데이트 함수(setOrderBy)를 받아 각 버튼이 고유의 동작을 수행하도록 설계함.\n\n정렬 상태 관리:\nsortBy와 order 두 가지 쿼리 파라미터를 orderBy라는 단일 상태로 관리함. 예를 들어, orderBy 상태를 &quot;sort-by_order&quot; 형식으로 업데이트하여, API 호출 시 이 값을 split하여 sortBy와 order로 분리해 사용하도록 함.\n\n\n\n페이지네이션\n문제점:\n페이지네이션을 위해 response에 totalCount를 받아 totalPages를 계산후 페이지네이션 컴포넌트에 내려줘야 하는데, 이때 query를 한 state에 관리 하다보니 api 호출함수에서 무한루프 api 호출이 발생함\n해결책: 조건문을 달아 totalPages가 바뀔때만 렌더링 되게 바꿈.\n문제: 가로 스크롤바 커스텀 디자인\n참고자료: 스크롤 바(Scrollbar) 스타일링\n\n크롬에서는 커스텀 스크롤바 디자인이 잘 적용되었으나, 파이어폭스에서는 적용되지 않는 문제가 발생함\n파이어폭스를 위한 CSS 코드(scrollbar-width 및 scrollbar-color)를 추가하였으나, 이로 인해 크롬의 스크롤바 디자인이 깨지는 현상이 발생\n파이어폭스의 경우 @supports를 사용하여 특정 CSS 속성 지원 여부를 확인한 뒤, 해당 속성을 적용함으로써 문제를 해결하려고 했으나, 크롬에서도 이 코드가 영향을 미치면서 디자인이 깨짐\n브라우저별로 별도의 CSS 파일을 로드하거나, 특정 클래스명을 사용하여 브라우저에 따라 다른 스타일을 적용해야할듯. 그런데 firefox 호환까지는 생각안해도 된다 하셔서 그냥 무시하기로 함\n\n문제: Loader 애니매이션 만들기\nCSS animation 구현에서 어려움을 겪음:\n\nview 에서 i 의 head 부분만 바운스되게 애니매이션 하고 싶음\n해결: 로고 svg에서 i의 head 부분을 지움\ndiv 로 같은 원형을 만들어서 바운스 되게 애니매이션 줌\n\n문제: vw, vh을 하니까 너비를 줄였을때 점이 i의 레터에서 시작하지 않음\n또는 위키링크 시도:\n\n해결: calc()\n\ncalc() 함수 사용해서 부모 요소의 절반 기준으로 이동시키게 조정\n\n화면 비율이 변경되도 고정 픽셀값을 넣어줘서 원하는 위치에 dot을 넣음\nleft: calc(50% - 75px);\ntop: calc(50% - 35px);\n문제: 브랜드 이미지 없을때 사용할 디폴트 UI (배경과 이니셜) 생성\n문제 상황\n회사 브랜드 이미지가 없는 경우 이니셜을 보여주는 디폴트 UI를 만들어야 했습니다. 배경색과 텍스트 색상의 대비가 중요했습니다.\n시도 1: 랜덤 색상 생성 + 색상 대비 비율 계산\n접근 방법:\n\n배경에 랜덤 HEX 코드 색상 생성\n대비 계산을 통해 적절한 텍스트 색상 결정\n\n참고 자료:\n\nRandom HEX Color Code Snippets\nGenerate Random HEX Color in JavaScript\n\n문제점: 배경이 밝은 경우 기본 하얀색 텍스트가 잘 보이지 않음\n시도 2: Relative Luminance 계산을 통한 대비 개선\n참고 자료:\n\nRelative Luminance\nContrast Minimum\nContrast Techniques\nRealities and Myths of Contrast and Color\n\n계산 방식:\n1. Relative luminance 공식:\n   L = 0.2126 * R + 0.7152 * G + 0.0722 * B\n\n   여기서 R, G, B는:\n   - R sRGB &lt;= 0.04045 ? R = R sRGB /12.92 : R = ((R sRGB +0.055)/1.055) ^ 2.4\n   - G sRGB &lt;= 0.04045 ? G = G sRGB /12.92 : G = ((G sRGB +0.055)/1.055) ^ 2.4\n   - B sRGB &lt;= 0.04045 ? B = B sRGB /12.92 : B = ((B sRGB +0.055)/1.055) ^ 2.4\n\n   그리고 R sRGB, G sRGB, B sRGB는:\n   - R sRGB = R 8bit /255\n   - G sRGB = G 8bit /255\n   - B sRGB = B 8bit /255\n\n2. 대비 비율 계산:\n   (L1 + 0.05) / (L2 + 0.05)\n\n   L1 = 밝은 색상의 상대 휘도\n   L2 = 어두운 색상의 상대 휘도\n\n3. 대비 비율 최소 기준: 3:1 이상\n\n* 휘도 임계값: 0.179 (어두운/밝은 색상 판단 기준)\n\n문제점:\n\n계산식대로 구현했는데 실제 눈으로 볼 때는 대비가 부족함\nW3C 기준을 충족해도 사용자 경험이 좋지 않음\n알고보니 오래된 공식(outdated formula)이었음\n\n시도 3: APCA(Advanced Perceptual Contrast Algorithm) 적용\n최신 APCA 공식을 찾아 적용하려 했으나, 구현 복잡도가 높고 더 근본적인 문제 발견!\n\n프론트엔드에서 브랜드 색을 랜덤 생성시 페이지 리로드나 페이지 이동하면 일관성 없이 브랜드 배경색이 계속 바뀜.\n\n최종 해결책: 데이터베이스에 색상 저장\n구현 방법:\n\n데이터베이스의 Company 모델에 brandColor 필드 추가 (enum 타입)\nbrandImage가 없는 경우 brandColor를 사용해 일관된 배경색 적용\n시각적으로 검증된 6가지 색상 조합을 미리 정의\n각 배경색에 맞는 텍스트 색상을 최소 8:1 대비 비율로 매칭\nAdobe color contrast checker\n\nseeding 전략:\n\n테스트 데이터 생성시 6가지 색상 중 랜덤 할당\n실제 사용자는 동일한 brandColor 값 유지로 일관성 확보\n\n결과:\n\n사용자 경험 개선: 일관된 브랜드 아이덴티티 유지\n접근성 향상: 모든 색상 조합이 8:1 이상의 높은 대비 비율 보장\n어도비 색상 대비 툴로 검증된 색상 조합 사용\n\n개선 및 학습 포인트\n\n해시 함수 활용: 회사명에서 일관된 해시값을 생성해 색상으로 변환하면 데이터베이스 변경 없이 일관성 유지 가능\n개인 실습 아이디어:\n\n해시 함수로 일관된 랜덤 색상 생성\nAPCA 알고리즘 구현해보기\n배경색에서 파생된 조화로운 대비 색상 자동 생성 기능\n\n\n\n이 경험을 통해 접근성과 사용자 경험 측면에서 색상 대비의 중요성을 깊이 이해하게 되었습니다.\n문제: 모달 리렌더링 이슈\n\nReact의 key 속성을 이용해 모달이 리렌더링될 때 새로운 컴포넌트로 인식되도록 시도했지만, 근본적인 문제를 해결하지 못했음. 특히, 순위가 내려갈 때 발생하는 특이한 문제는 여전히 존재했음\n모달을 부모 컴포넌트에서 상태로 관리하여 props로 전달하는 방식도 고려했음. 그러나 모달을 부모 컴포넌트에서 내려주는 방식은 드릴링이 심해지는 문제가 있었음. 이로 인해 코드 복잡성이 증가하고, 유지보수성이 떨어질 우려가 있었음\n\n📝 연관 노트"},"My-Garden/Seedlings/typescript-session-by-lee":{"slug":"My-Garden/Seedlings/typescript-session-by-lee","filePath":"My-Garden/Seedlings/typescript-session-by-lee.md","title":"타입스크립트 이븐하게 살펴보기","links":["/"],"tags":["seedling","TypeScript","특강","이정환"],"content":"타입스크립트 이븐하게 살펴보기\n\n이정환 강사님의 타입스크립트 특강 정리\n\n이 노트의 핵심 키워드\n\n점진적 타입 시스템 (Gradual Type System)\n타입 추론 (Type Inference)\n타입 호환성 (Type Compatibility)\n업캐스팅과 다운캐스팅\n특수 타입 (Unknown, Never, Any)\nTS 컴파일 과정\n타입과 집합의 관계\n\n1. 타입스크립트 소개\n\n타입스크립트는 마이크로소프트에서 개발한 오픈 소스 프로그래밍 언어로, 자바스크립트의 상위 집합(Superset).\n즉, 모든 자바스크립트 코드는 타입스크립트 코드이기도 하지만, 타입스크립트는 자바스크립트에 정적 타입 시스템을 추가한것.\n\ngraph TD\n    A[JavaScript] --&gt; B[TypeScript]\n    B --&gt; C[정적 타입 시스템]\n    B --&gt; D[객체 지향 기능]\n    B --&gt; E[ECMAScript 최신 기능]\n\n2. 타입 시스템 개념\n타입 시스템은 프로그래밍 언어에서 타입과 관련된 문법 체계를 의미합니다. 다음 세 가지 핵심 질문으로 구분할 수 있음:\n\n어떤 기준으로 타입을 결정하는가?\n타입 검사는 언제 실행되는가?\n타입 검사는 어떤 방식으로 진행되는가?\n\n3. 동적 타입 시스템 vs 정적 타입 시스템\n3.1 동적 타입 시스템 (Python, JavaScript)\n\n특징: 정적 타입 시스템보다 훨씬 더 유연함\n타입 검사 시점: 런타임 (실행 중에 타입 결정)\n컴파일 시 타입 검사: ❌\n장점: 매우 자유로움, 타입 관련 코드를 작성할 필요 없음\n단점: 프로그램 실행 전에 타입 오류 감지 불가능, 안정성 떨어짐\n\n// 동적 타입 시스템 예시 (JavaScript)\nlet x = 10 // 숫자\nx = &quot;Hello&quot; // 문자열로 변경 가능\nx = { id: 1 } // 객체로도 변경 가능\n3.2 정적 타입 시스템 (Java, C)\n\n특징: 매우 엄격하고 견고한 타입 시스템\n타입 검사 시점: 컴파일 타임\n변수 타입 정의: 명시적으로 정의 필요\n장점: 매우 견고함, 대부분의 오류는 컴파일 시점에 파악 가능\n단점: 자유롭지 못함, 타이핑 양이 많아짐\n\n// 정적 타입 시스템 예시 (Java)\nint x = 10;      // 숫자로 선언\nx = &quot;Hello&quot;;     // 컴파일 오류 발생!\n3.3 두 시스템 비교\ngraph LR\n    A[타입 시스템] --&gt; B[동적 타입 시스템]\n    A --&gt; C[정적 타입 시스템]\n    B --&gt; D[유연성 높음]\n    B --&gt; E[런타임 검사]\n    C --&gt; F[안정성 높음]\n    C --&gt; G[컴파일 시 검사]\n\n4. TypeScript: 점진적 타입 시스템\nTypeScript는 두 타입 시스템의 장점만 추린 점진적 타입 시스템(Gradual Type System)!\n\n장점 1: 매우 자유롭게 코딩 가능\n장점 2: 컴파일 타임에 타입 검사로 안정성 확보\n타입 선언 방식: 직접 선언 또는 자동 추론 가능\n\n// 타입 직접 선언\nlet age: number = 30\n \n// 타입 추론\nlet name = &quot;John&quot; // string으로 자동 추론\n \n// 복잡한 타입도 정의 가능\ntype User = {\n  id: number\n  name: string\n  isActive: boolean\n}\n \nconst user: User = {\n  id: 1,\n  name: &quot;Alice&quot;,\n  isActive: true,\n}\nTypeScript는 타입 추론(Type Inference) 기능을 통해 명시적으로 타입을 선언하지 않아도 코드 맥락에서 적절한 타입을 자동으로 추론ㄴ\n5. TypeScript 컴파일 과정\nTypeScript가 실행되는 과정\nflowchart TD\n    A[TypeScript 코드] --&gt;|컴파일| B[타입 검사]\n    B --&gt;|검사 실패| C[오류 발생]\n    B --&gt;|검사 성공| D[JavaScript 코드 생성]\n    D --&gt;|JS 엔진 실행| E[바이트코드 변환]\n    E --&gt; F[실행]\n\n\n컴파일: TypeScript 컴파일러가 타입 검사를 수행\n타입 오류 발견 시: 타입 검사 실패로 컴파일 중지\n타입 검사 성공 시: JavaScript 코드로 변환\nJavaScript 실행: 변환된 코드는 JS 엔진에서 실행\n\nTypeScript의 주요 목적은 JavaScript에 타입 검사 안전장치를 추가하는 것으로 타입 검사가 통과한 코드만 JavaScript로 변환되어 실행되므로, 런타임 오류를 크게 줄일 수 있다.\n6. TypeScript의 모든 타입은 결국 ‘집합’이다\nTypeScript를 학습하며 꼭 마주치게 되는 중요 개념들:\n\n특수 타입 (Any, Never, Unknown)\n타입 호환성 (Type Compatibility)\n\n6.1 집합(Set)의 관점에서 타입 이해하기\n타입을 집합의 관점에서 해석하면, 각 타입은 특정 조건을 만족하는 값들의 집합이라고 볼 수 있다.\n\n리터럴 타입: 하나의 값만 포함하는 타입 (예: 1, &quot;hello&quot;)\n기본 타입: 특정 종류의 여러 값을 포함하는 타입 (예: number, string)\n\n// 리터럴 타입\nlet one: 1 = 1\nlet greeting: &quot;hello&quot; = &quot;hello&quot;\n \n// 기본 타입\nlet count: number = 42\nlet message: string = &quot;TypeScript&quot;\n6.2 타입 계층 구조\nTypeScript의 타입들은 포함 관계에 따른 계층 구조를 형성:\ngraph TD\n    A[unknown] --&gt; B[object]\n    A --&gt; C[boolean]\n    A --&gt; D[number]\n    A --&gt; E[string]\n    A --&gt; F[기타 타입]\n    D --&gt; G[숫자 리터럴 타입]\n    E --&gt; H[문자열 리터럴 타입]\n    I[never] --&gt; G\n    I --&gt; H\n    I --&gt; J[기타 리터럴 타입]\n\n\n슈퍼타입(Supertype): 더 넓은 범위의 값을 포함하는 타입 (예: number)\n서브타입(Subtype): 더 좁은 범위의 값을 포함하는 타입 (예: 숫자 리터럴 1)\n\n예를 들어, Number 타입은 모든 Number 리터럴 타입의 슈퍼타입이다.\n6.3 타입 호환성(Type Compatibility)\n타입 호환성은 타입 간의 호환 여부를 판단하는 기준으로 TypeScript에서는 타입 계층 구조에 기반하여 판단한다.\n\n업캐스팅(Upcasting): 서브타입에서 슈퍼타입으로의 변환 (안전하여 허용)\n다운캐스팅(Downcasting): 슈퍼타입에서 서브타입으로의 변환 (안전하지 않아 기본적으로 금지)\n\nlet a: number = 999\nlet b: 1 = 1\n \n// 업캐스팅: 서브타입(1)에서 슈퍼타입(number)으로 - 안전하므로 허용\na = b // 가능\n \n// 다운캐스팅: 슈퍼타입(number)에서 서브타입(1)으로 - 안전하지 않아 불가능\nb = a // 컴파일 오류\n7. 특수 타입\n7.1 Unknown 타입\n\n정의: 모든 집합을 포함하는 전체집합(슈퍼셋)\n특징:\n\n모든 타입의 값을 저장할 수 있음 (모든 타입의 슈퍼타입)\nunknown 타입의 값은 타입 체크 없이 다른 타입에 할당 불가\n\n\n\nlet value: unknown\n \nvalue = 42 // 가능\nvalue = &quot;Hello&quot; // 가능\nvalue = { id: 1 } // 가능\n \nlet num: number\nnum = value // 오류: &#039;unknown&#039; 타입을 &#039;number&#039; 타입에 할당할 수 없음\n \n// 타입 가드를 통해 사용 가능\nif (typeof value === &quot;number&quot;) {\n  num = value // 이제 가능\n}\nUnknown 타입은 어떤 타입의 값이 저장될지 예상할 수 없을 때 사용.\n/* 매개변수의 타입에 따라 다른 동작을 수행\n- number: toFixed() 사용\n- string 타입일 때: toUpperCase() 사용\n- 그 외: 값을 그대로 반환 */\n \nfunction processValue(param: unknown) {\n  if (typeof param === &quot;number&quot;) {\n    return param.toFixed(2)\n  } else if (typeof param === &quot;string&quot;) {\n    return param.toUpperCase()\n  }\n  return param\n}\n7.2 Never 타입\n\n정의: Unknown의 반대로, 공집합과 같음\n특징:\n\n어떤 타입의 값도 저장할 수 없음\n모든 타입의 서브타입\n어떤 값도 Never 타입이 될 수 없음\n\n\n\n// 정상적으로 종료되지 않는 함수\nfunction throwError(): never {\n  throw new Error(&quot;An error occurred!&quot;)\n}\n \n// 무한 루프 함수\nfunction infiniteLoop(): never {\n  while (true) {}\n}\nNever 타입 활용 예:\n\n절대 반환되지 않는 함수의 반환 타입\n발생할 수 없는 조건을 표현할 때\n제네릭 타입 내에서 불가능한 케이스를 처리할 때\n\n7.3 Any 타입\n\n정의: 타입 검사를 받지 않는 “치트키” 같은 타입\n특징:\n\n모든 타입의 슈퍼타입이자 서브타입처럼 동작\nUnknown과 Never를 합친 것과 유사한 성질\n타입 안전성을 우회하는 “탈출구”\n\n\n\nlet anyValue: any = 10\nanyValue = &quot;hello&quot; // 가능\nanyValue = { property: true } // 가능\n \nlet num: number = anyValue // 다운캐스팅인데도 가능\nlet str: string = anyValue // 다운캐스팅인데도 가능\n\nAny 타입은 최대한 사용하지 않는 것을 권장.\nAny를 사용 하면 JavaScript를 사용하는 것과 진배 없음;\n\n8. TypeScript 마이그레이션 팁\nJavaScript 프로젝트를 TypeScript로 마이그레이션하는 몇 가지 실용적인 팁:\n\n\n핵심 코어 모듈 위주로 변환 시작\n\n가장 중요하고 자주 사용되는 모듈부터 변환\n\n\n\n실제 비즈니스에 영향을 주는 부분 우선적으로 처리\n\n선택과 집중을 통해 효율적인 마이그레이션\n\n\n\nallowJS 옵션 활용\n\ntsconfig.json에서 &quot;allowJs&quot;: true 설정\n파일 단위로 점진적으로 변환 가능\n\n\n\n빨간줄 오류부터 해결\n\n가장 명백한 타입 오류부터 해결하고 점진적으로 확장\n\n\n\n타입 추론이 잘 되는 방향으로 코드 작성\n\nTypeScript의 타입 추론 능력을 최대한 활용\n\n\n\n// 좋은 예: 타입 추론이 잘 되는 코드\nconst user = {\n  id: 1,\n  name: &quot;John&quot;,\n  isActive: true,\n}\n \n// 필요한 경우에만 명시적 타입 선언\ninterface User {\n  id: number\n  name: string\n  isActive: boolean\n  details?: {\n    address: string\n    phone?: string\n  }\n}\n\n마이그레이션 중에도 새 기능 개발이 가능하도록 설계\n\n새 기능이나 hotfix가 필요할 때 작업이 가능하도록 모듈식 접근\n\n\n\n외) 강사님이 추천하는 효과적인 학습법\n\n\n다른 사람에게 가르치기\n\n다른 사람에게 가르치려는 과정에서 가장 많이 배우고 체득됨\n\n\n\n배운 내용 블로그에 정리하기\n\n글로 정리하면서 개념을 더 깊게 이해\n\n\n\n모든 인과관계 파악하기\n\n모든 인과관계를 다 파악할 때까지 정리하는 습관 들이기\n\n\n\n좋아하는 주제 찾기\n\n자신이 좋아하는 주제를 찾아 몰입하는 것이 중요\n몰입 이론에 의거한 학습법\n\n\n\n소프트콘 서비스 사례 참고\n\n인터넷 방송 랭킹을 보여주는 개인 토이 프로젝트\nvelog.io/@dus532/posts\n\n\n\n‘함께 자라기’ 책에서 소개된 학습 방법론 적용\n\n\n10. 종합 정리: TypeScript의 핵심 가치\n\n타입 안전성: 컴파일 타임에 오류를 발견하여 런타임 버그 감소\n개발자 경험 향상: 코드 자동 완성, 리팩토링, 문서화 기능 제공\n확장성: 대규모 애플리케이션 개발에 적합한 구조 제공\n점진적 적용: 기존 JavaScript 코드에 점진적으로 도입 가능\n최신 JavaScript 기능: ECMAScript 최신 기능을 지원하면서도 하위 호환성 유지\n\n⏭ 다음 단계 (What’s Next?)\n\n 타입스크립트로 간단한 프로젝트 마이그레이션 시도하기\n 타입스크립트의 고급 기능(제네릭, 유틸리티 타입) 학습하기\n 이정환 강사의 다른 타입스크립트 관련 자료 찾아보기\n\n📚 References &amp; Resources\n\n코드잇 특강\n\n📝 연관 노트\n\n🌿 Budding: \n🌳 Evergreen: \n"},"My-Garden/index":{"slug":"My-Garden/index","filePath":"My-Garden/_index.md","title":"My Garden","links":[],"tags":[],"content":"Amber’s Dev-log 🌱🌿🌳\n간단한 메모에서 시작해 개선해 나가는 디지털 정원입니다.\n🌱 씨앗 단계 (Seedlings)\n새롭게 발견한 아이디어와 질문들이 싹트는 곳입니다. 아직 초기 단계의 생각들이 자라나기 시작하는 공간입니다.\n🌿 성장 단계 (Buddings)\n씨앗이 자라나 잎을 피우는 단계입니다. 아이디어가 발전하고 구체화되어가는 노트들이 모여있습니다.\n🌳 완성 단계 (Evergreens)\n충분히 성장하여 단단해진 생각들입니다. 깊이 있게 정리되고 체계화된 지식을 담고 있습니다.\nß"},"Posts/index":{"slug":"Posts/index","filePath":"Posts/_index.md","title":"Posts","links":[],"tags":[],"content":"글 모음 📝\n이곳은 제가 정리한 지식과 생각들을 공유하는 공간입니다. 개발 과정에서 배운 것들, 문제 해결 방법, 그리고 다양한 기술적 주제에 대한 글들을 찾아보실 수 있습니다.\n글을 통해 제 경험이 여러분에게도 도움이 되길 바랍니다. 질문이나 의견이 있으시면 언제든지 연락주세요!"},"Posts/query-key-factories":{"slug":"Posts/query-key-factories","filePath":"Posts/query-key-factories.md","title":"Query Key 관리하기 - query key factories","links":["My-Garden/Seedlings/query-key-factories"],"tags":["post","tanstack-query","query-key"],"content":"💡 쿼리키 관리 팁 - QueryKey factory\n\n배경\n\n쿼리키에 params를 포함하면서 페이지를 param별로 캐싱하려니 좀 더 정돈된 쿼리키 사용이 필요했다. 배열이 길어지다 보니 헷갈리기도 하고, 변수로 체계화 시켜서 중앙에서 관리하는 것이 좋을 것 같았다.\n🔍 Research\n관련 예시를 찾던 도중, Tanstack-query를 관리하는 개발자의 블로그(TkDodo)에서 쿼리키 관리 방식에 대한 포스트를 발견했다. 1\n커뮤니티에서도 이런 패턴을 확장한 라이브러리가 있는데, 가장 인기있는 것은 @lukemorales/query-key-factory[^2]이다. \n이 라이브러리는 타입 안전한 쿼리키 생성과 자동 완성 기능을 제공하며, 특히 TypeScript 프로젝트에서 유용하다.\n그치만 이 글에서는 쿼리키 패턴 비교하는 것이 목적이라 이 라이브러리는 다루지 않는다.\n쿼리키 비교 분석: 배열 기반 vs 객체 기반\n보통의 배열 기반 쿼리키\n\n배열에 원시값으로 나열\n\nconst getAllUsers = useQuery([&quot;users&quot;]) // [&quot;users&quot;] 쿼리키에 에 getAllUsers로 fetch한 데이터가 저장됨\nconst getUserById = useQuery([&quot;users&quot;, userId]) // [&quot;users&quot;, userId] 쿼리키에 getUserById로 fetch한 데이터가 저장됨\nTkDodo의 객체 기반 쿼리키 패턴\n\nTkDodo는 모든 쿼리키를 배열 안의 단일 객체로 표현하는 방식을 권장한다.\n\n// 중앙에서 쿼리키를 변수로 관리하며 매서드로 생성\nconst todoKeys = {\n  // ✅ all keys are arrays with exactly one object\n  // = 모든 키는 정확히 하나의 객체를 포함한 배열\n  all: [{ scope: &quot;todos&quot; }] as const,\n  lists: () =&gt; [{ ...todoKeys.all[0], entity: &quot;list&quot; }] as const, // [{scope: &quot;todos&quot;, entity: &quot;list&quot;}]\n  list: (state: State, sorting: Sorting) =&gt; [{ ...todoKeys.lists()[0], state, sorting }] as const,\n  // [{scope: &quot;todos&quot;, entity: &quot;list&quot;, state, sorting}]\n}\n이 패턴의 핵심:\n\n모든 쿼리키가 정확히 하나의 객체를 포함한 배열로 구성\n객체 내부에 모든 필요한 데이터를 키-값 쌍으로 표현\n\n예: scope: &quot;todos&quot;, entity: &quot;list&quot;, id: 5 등\n\n\n\n배열 기반 쿼리키의 한계\n\n일반 원시값의 요소의 배열시 순서에 의존하기 때문에 순서가 바뀔시 다른 쿼리로 인식됨 ⚠️\n\nconst getAllUsers = useQuery([&quot;users&quot;])\nconst getUserById = useQuery([&quot;users&quot;, userId])\nconst getUserPosts = useQuery([&quot;users&quot;, userId, &quot;posts&quot;])\n \n// getUserPosts와 공집합이지만, 순서가 달라 무효화 오류 발생함.\nqueryClient.invalidateQueries({ queryKey: [&quot;posts&quot;, userId, &quot;users&quot;] })\n권장되는 방식: TkDodo의 단일 객체 패턴\n\n위의 문제는 TkDodo가 제안한 단일 객체 패턴으로 해결할 수 있다.\n\n// 단일 객체 패턴으로 개선\nconst getUsersQueries = {\n  all: [{ entity: &quot;users&quot; }],\n  detail: (userId) =&gt; [{ entity: &quot;users&quot;, id: userId }],\n  posts: (userId) =&gt; [{ entity: &quot;users&quot;, id: userId, relation: &quot;posts&quot; }],\n}\n \n// 사용 예시\nconst { data: allUsers } = useQuery({ queryKey: getUsersQueries.all })\nconst { data: user } = useQuery({ queryKey: getUsersQueries.detail(5) })\nconst { data: userPosts } = useQuery({ queryKey: getUsersQueries.posts(5) })\n \n// 객체 속성(properties) 기반 매칭\nqueryClient.invalidateQueries({ queryKey: [{ entity: &quot;users&quot;, id: 5 }] })\n이 방식은 객체 속성(properties) 기반으로 매칭되므로 순서에 의존하지 않고, 더 유연한 쿼리 관리가 가능하다.\n\n쿼리 비교 알고리즘 이해하기\nTanstack-query 공식문서2에 따르면 invalidateQueries나 removeQueries 같은 메서드를 사용시, 깊은 부분 일치 검색(deep partial matching: 객체의 속성들이 부분적으로 일치하는지 깊게 검사하는 알고리즘) 알고리즘을 사용한다 소개한다.\n이 알고리즘은 쿼리키의 prefix(접두사) 기반으로 작동하기 때문에 배열의 첫 부분부터 순서가 일치해야 한다. 즉, 캐시된 퀴리키의 시작부분이 무효화하려는 패턴과 정확히 일치해야 된다.\n쿼리 비교 알고리즘\n\n정확히 어떻게 비교할까?  TanStack Query의 깃허브 소스 코드를 단순화한 알고리즘:\n\n// queryKey 비교 알고리즘 (단순화됨)\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean {\n  return partialDeepEqual(a, b)\n}\n \n// 객체의 부분 일치를 확인하는 함수\nfunction partialDeepEqual(a: any, b: any): boolean {\n  // 1. 두 값이 정확히 같다면 일치\n  if (a === b) {\n    return true\n  }\n \n  // 2. 타입이 다르면 불일치\n  if (typeof a !== typeof b) {\n    return false\n  }\n \n  // 3. 두 값이 모두 객체인 경우\n  if (a &amp;&amp; b &amp;&amp; typeof a === &quot;object&quot; &amp;&amp; typeof b === &quot;object&quot;) {\n    // b의 모든 속성이 a에 존재하고 일치하는지 확인\n    return !Object.keys(b).some((key) =&gt; !partialDeepEqual(a[key], b[key]))\n  }\n \n  return false\n}\n단방향 매칭 이해하기\n이 비교 알고리즘은 단방향으로 동작한다는걸 이해하는게 중요하다.\n\nTanStack Query는 캐시된 쿼리키(a)와 무효화 패턴(b)을 비교한다.\n무효화 패턴(b)이 캐시된 쿼리키(a)의 부분 집합인지 확인한다.\n즉, “무효화 패턴의 모든 속성이 캐시된 쿼리키에도 있고 값이 같은가?”를 검사한다.\n\n이는 실제 중첩된 쿼리키를 무효화하는데 중요한 특성이다.\n예제로 이해하기\n예를 들어, 다음과 같은 쿼리키가 있다고 가정해보자.\n1. 캐시에 있는 쿼리키들\n1. [{ scope: &#039;users&#039;, id: 5, entity: &#039;detail&#039; }]\n2. [{ scope: &#039;users&#039;, id: 5, subEntity: &#039;posts&#039; }]\n3. [{ scope: &#039;users&#039;, id: 7, subEntity: &#039;posts&#039; }]\n4. [{ scope: &#039;posts&#039;, id: 10 }]\n\n2. 무효화 명령을 실행:\nqueryClient.invalidateQueries({\n  queryKey: [{ scope: &quot;users&quot;, id: 5 }],\n})\n3. 결과:\n\n쿼리 1: ✅ 무효화 됨 (패턴의 모든 속성이 포함됨)\n쿼리 2: ✅ 무효화 됨 (패턴의 모든 속성이 포함됨)\n쿼리 3: ❌ 무효화 안됨 (id가 다름)\n쿼리 4: ❌ 무효화 안됨 (scope이 다름)\n\n4. 다시, 왜 “단방향”인가?\n\n무효화 패턴(b)이 쿼리키(a)의 부분 집합인지만 확인.\n역방향(쿼리키가 패턴의 부분 집합인지)은 확인하지 않음.\n\n객체 기반 쿼리키 팩토리 구조와 활용\n\n객체 기반 쿼리키 팩토리의 계층적 구조와 메서드별 역할:\n\nconst userKeys = {\n  // 1. 기본 스코프 정의\n  all: [{ scope: &quot;users&quot; }] as const,\n \n  // 2. entity: list 구조 생성\n  lists: () =&gt; [{ ...userKeys.all[0], entity: &quot;list&quot; }] as const,\n  list: (filters = {}) =&gt; [{ ...userKeys.lists()[0], ...filters }] as const,\n \n  // 이 후 entity 별로 메서드 추가 (예시: detail)\n  details: () =&gt; [{ ...userKeys.all[0], entity: &quot;detail&quot; }] as const,\n  detail: (userId) =&gt; [{ ...userKeys.details()[0], id: userId }] as const,\n \n  ...\n}\n메서드 간의 계층 구조\n \nuserKeys.all → 기본 도메인 정의\n  ├── userKeys.lists() → 목록 관련 기본 구조\n  │     └── userKeys.list(filters) → 최종 목록 쿼리 (필터 포함)\n  │\n  └── userKeys.details() → 상세 정보 기본 구조\n        └── userKeys.detail(userId) → 특정 사용자 상세 정보\n \n \n메서드 구조 (Domain &gt; Entity &gt; Query)\n1. userKeys.all - 기본 스코프\n\n모든 users 관련 쿼리를 한 번에 무효화할 때 유용\n반환값: [{ scope: &quot;users&quot; }]\n예: queryClient.invalidateQueries({ queryKey: userKeys.all })\n\n2-1. userKeys.lists() - 목록 기본 쿼리키\n\n모든 users의 list(목록) 쿼리키\n모든 list 쿼리(필터와 상관없이)를 무효화할 때 사용\n반환값: [{ scope: &quot;users&quot;, entity: &quot;list&quot; }]\n예: queryClient.invalidateQueries({ queryKey: userKeys.lists() })\n\n2-2. userKeys.list(filters) - 필터가 적용된 list 쿼리키\n\n구체적인 필터가 추가된 list 쿼리키\n특정 필터 조건의 목록 데이터를 조회하거나 무효화할 때 사용\n반환값: [{ scope: &quot;users&quot;, entity: &quot;list&quot;, filters }]\n예: 특정 페이지 목록 조회: useQuery({ queryKey: userKeys.list({ page: 1, limit: 10 }) })\n\n객체 기반 쿼리키의 장점\n\n유연한 쿼리 무효화: 객체의 properties(프로퍼티)를 기반으로 쿼리를 더 유연하게 무효화할 수 있음\n구조 분해를 통한 명확한 접근: 쿼리 함수에서 객체의 명명된 속성으로 바로 접근 가능\n\n// 쿼리 함수에서 구조 분해 활용하기\nconst fetchTodos = async ({\n  // 쿼리키의 첫 번째 요소가 객체이므로 명명된 속성으로 바로 접근 가능\n  queryKey: [{ state, sorting, filters }],\n}: QueryFunctionContext&lt;ReturnType&lt;typeof todoKeys.list&gt;&gt;) =&gt; {\n  // ✅ URL 빌드시 위치가 아닌 속성명으로 접근하므로 안전\n  const response = await axios.get(`todos/${state}?sorting=${sorting}&amp;limit=${filters.limit}`)\n  return response.data\n}\n내 프로젝트에 적용하기\n객체 기반 방식 적용시 고려 사항\n객체 기반 방식의 가장 큰 장점은 속성 기반 매칭을 통한 유연한 쿼리 관리이다. 이를 최대한 활용하려면 다음과 같이 직접 속성값을 지정하여 무효화하는 것이 가장 효과적이다.\n(가독성 좋고, 편리함)\n// 속성값으로 쉽게 무효화 하기\n// 모든 투두 삭제\nqueryClient.removeQueries({\n  queryKey: [{ scope: &quot;todos&quot; }],\n})\n \n// todos 도메인 안에 모든 목록 리셋\nqueryClient.resetQueries({\n  queryKey: [{ scope: &quot;todos&quot;, entity: &quot;list&quot; }],\n})\n \n// 어느 도메인이든 모든 목록 무효화 (실수로 다른 도메인의 list까지 무효화 될 수 있음)\nqueryClient.invalidateQueries({\n  queryKey: [{ entity: &quot;list&quot; }],\n})\n하드 코드 방식의 문제\n그러나 이 장점을 위해 하드 코딩으로 쿼리키 작성시 아래와 같은 문제점이 있다.\n\n속성 이름 오타: scope를 scop으로 잘못 입력하면 아무 쿼리도 무효화되지 않음\n구조 변경 시 위험: 나중에 팩토리 구조를 변경하면 하드코딩된 객체와 불일치 발생\n일관성 유지 어려움: 팀원들이 각자 다른 방식으로 객체를 구성할 위험\n\n팩토리 매서도 호출을 통한 대안\n물론 중앙에서 관리하기 떄문에 하드코딩 말고 팩토리 함수를 통한 스코프 무관 무효화 할 수 있다.\n// 팩토리 매서드를 호출 해 사용 | 하드코딩 ❌\nqueryClient.invalidateQueries({\n  queryKey: todoKeys.lists(), // [{ scope: &quot;todos&quot;, entity: &quot;list&quot; }]\n})\n그러나 이런 식으로 활용된다면, 객체 기반 접근법의 장점인 가독성과 편리성이 상쇄된다.\n나는 애초에 모든 쿼리키를 변수로 둬 중앙에서 한번에 관리하는것에 제일 우선순위이기 때문에, 이 장점에도 불구 하드코딩은 피하고 싶었고,\n이 장점을 포기하니 배열 + 객체 접근법이 훨씬 편리하다 판단했다.\n내 채택한 방식\n\n내 프로젝트에서 선택한 방식은 배열 + 객체 접근법이다.\n\n나는 애초에 모든 쿼리키를 변수로 두어 중앙에서 관리하는 것을 최우선으로 생각했기 때문에, 객체 기반의 유연성보다 팩토리 함수를 통한 안전성을 선택했다.\n이러한 상황에서는 배열 + 객체(가변이 높은 매개변수 그룹화) 혼합 접근법이 더 직관적이고 편리하다고 판단했다.\n// 중앙에서 관리하는 쿼리키 팩토리\nexport const workKey = {\n  all: [&quot;works&quot;],\n  // 반환값: [&quot;works&quot;]\n \n  lists: () =&gt; [...workKey.all, &quot;list&quot;],\n  // 반환값: [&quot;works&quot;, &quot;list&quot;]\n \n  list: (challengeId, params = {}) =&gt; [...workKey.lists(), challengeId, { ...params }],\n  // 반환값: [&quot;works&quot;, &quot;list&quot;, challengeId, { ...params }]\n \n  details: () =&gt; [...workKey.all, &quot;detail&quot;],\n  // 반환값: [&quot;works&quot;, &quot;detail&quot;]\n \n  detail: (workId) =&gt; [...workKey.details(), workId],\n  // workKey.detail(8) 반환값: [&quot;works&quot;, &quot;detail&quot;, 8]\n \n  feedbacks: (workId) =&gt; [...workKey.detail(workId), &quot;feedbacks&quot;],\n  // workKey.feedbacks(5) 반환값: [&quot;works&quot;, &quot;detail&quot;, 5, &quot;feedbacks&quot;]\n}\n// 항상 팩토리 매서드를 호출 해 사용 | 하드코딩 ❌\nconsole.log(workKey.list(challengeId, { ...params }))\n// 반환값: [&quot;works&quot;, &quot;list&quot;, challengeId, { ...params }]\n특징\nREST API 구조와 유사한 계층적 구조 패턴으로 접근했다.\n\n[0]인덱스: 데이터 도메인(DB 엔티티) - “works”\n[1]인덱스: 조회 유형 - “list” 또는 “detail”\n[2]인덱스: 식별자 - challengeId 또는 workId\n[3]인덱스: 가변적인 매개변수 - {필터링, 정렬, 페이지네이션 등}\n\n채택 이유\n프로젝트 적합성\n\n명확한 도메인 구조에 적합 (“works”, “challenges” 등)\n백엔드 API 구조와 일관성 유지 (REST 패턴)\n팀원들의 이해도가 높음\n중소 규모 프로젝트에 충분한 기능 제공\n중앙 관리 방식에 최적화\n\n기술적 장점\n\n하드코딩 없이 팩토리 메서드 사용으로 실수 방지\n오타 위험 감소\n명확한 계층 구조 (예: [‘works’, ‘list’, challengeId])\nquery params 같은 그룹화 시키기 좋은 가변 매개변수만 객체로 관리하여 유연성 확보\n계층적 도메인 분리가 명확하여 의도치 않은 무효화 방지\n\n두 접근법 비교 정리\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n특성TkDodo 객체 기반내 배열 기반 접근법유연성속성 기반 매칭으로 매우 유연함prefix 기반 매칭으로 유연성 제한적직관성객체 속성으로 구분하여 어려울 수 있음REST API와 유사해 직관적타입 안전성TypeScript와 결합 시 뛰어남위치 기반이라 타입 안전성 낮음구조 분해명명된 속성으로 접근 용이위치 기반 접근으로 오류 가능성적합한 상황복잡한 대규모 프로젝트구조가 명확한 소규모 프로젝트\n배열 + 객체 방식의 제한 사항\n그러나 역시 각 방법이 장단점이 있기 때문에 프로젝트 특성에 따라 적합한 방법을 선택해야 한다.\n현재 프로젝트 사이즈에서는 이 방식이 더 적절하다 판단되지만 프로젝트가 성장하면서 복잡한 관계 표현의 어려운 부분은 확실히 있었다.\n항상 계층적인 관계일 수 만은 없기 때문에 확장성을 위해 현재에서(리액트+자바스크립트) → 타입스크립트와 넥스트로 마이그레이션시 타입 안정성도 보장하고 더 유연한 객체 기반 접근법으로 리팩토링 할것이다.\n정리\nTkDodo의 쿼리키 팩토리의 장점\n\n쿼리키 관리 중앙화\n쿼리키 생성 로직 재사용성\n쿼리키 무효화 유연성\n타입 안전성\n\n고려해야 할 단점\n\n초기 설정 오버헤드: 쿼리키 팩토리 패턴은 초기 구현에 시간이 필요.\n간단한 사용 사례에서의 복잡성: 매우 간단한 앱에서는 과도한 추상화 일 수 있음.\n학습 곡선: 팀원들이 이 패턴에 익숙해지는 데 시간이 필요할 수 있음.\n\n객체 기반과 배열 기반 접근법 모두 각자의 장단점이 있으며, 프로젝트의 특성과 팀의 선호도에 따라 적절한 접근법을 선택하는 것이 중요한거 같다.\n\n⏭ 다음 단계 (What’s Next?)\n\n 현재 리액트 + 자바스크립트 프로젝트 → 넥스트 + 타입스크립트로 전환할때 TkDodo의 방식으로 적용해보기\n query key factory 관리 하는 라이브러리 확인해보기 @lukemorales/query-key-factory\n 쿼리 필터 관련 문서 정리 (QueryFilter &amp; MutationFilter) 쿼리 필터 관련 문서\n\n📚 References &amp; Resources\nDorfmeister, D. 2021, “Leveraging the Query Function Context”\n📝 연관 노트\n\n🌱 초기 아이디어 QueryKey factory 리서치\n\n\nFootnotes\n\n\n링크:Leveraging the Query Function Context ↩\n\n\n링크:TanStack Query - Query Matching with invalidateQueries ↩\n\n\n"},"Posts/svg-sprite-method":{"slug":"Posts/svg-sprite-method","filePath":"Posts/svg-sprite-method.md","title":"SVG 아이콘 최적화 시키기 (feat. sprite)","links":["My-Garden/Seedlings/avoid-svg-in-js"],"tags":["post","project"],"content":"배경\n정말 간단한 요구사항에서 시작했다. Docthru 프로젝트에서 SVG 아이콘이 20-30개 정도 사용되고 있었는데, Next.js 환경에서 이미지 최적화가 필요하다고 느꼈다. \n처음에는 당연히 Next의 &lt;Image&gt; 컴포넌트를 사용하는 방법도 고려했고, svg 이미지를 동적으로 색상 변경도 하고 싶어서 svgr이나 다른 SVG 컴포넌트화 라이브러리를 찾아보고 있었다.\n// 이런 방식으로 사용하려고 했었다\nimport HeartIcon from &quot;./HeartIcon.svg&quot;\nconst App = () =&gt; &lt;HeartIcon fill=&quot;red&quot; /&gt;\n근데 리서치하는 과정에서 중요한 문제를 발견했다. SVG 파일을 이렇게 리액트 컴포넌트로 변환하는 접근법이 사실 JS 번들 크기를 크게 증가시킨다는 것이다. \n단순히 “아이콘 쓰는 방법”을 찾던 것에서 “최적화된 아이콘 시스템을 어떻게 구축할까?”라는 더 큰 문제로 확장된 것이다.\nSVG-in-JS 방식의 문제점\n계속 파고들면서 SVG-in-JS 방식의 구체적인 문제점을 파악했다\n\n번들 크기와 파싱 시간: JS 번들이 커질수록 브라우저가 파싱하고 실행하는 시간이 길어진다. 이게 성능에 직접적인 영향을 준다.\n기기 다양성 고려: 최신 고성능 기기에서는 차이가 크게 느껴지지 않을 수 있지만, 전 세계 사용자의 75%는 중저가 기기를 사용한다는 통계를 봤다. 우리는 모든 사용자를 배려해야 한다.\n잘못된 접근법: SVG는 본질적으로 이미지를 설명하는 XML 태그인데, 이걸 JavaScript로 처리하는 건 형식에 맞지 않다. 그냥 이미지로 다루는 게 더 자연스럽다.\n\n대안\n1. Image + SVG 방식 (&lt;img src=&#039;icon.svg&#039;&gt;):\n\n장점: 가장 무난하고 Next의 &lt;Image&gt;로 최적화 가능\n단점: 동적 CSS 스타일링이 어렵고, 매 아이콘마다 HTTP 요청이 발생\n\n2. SVG-in-CSS 방식: CSS 속성을 사용하여 SVG 삽입\nbackground-image / mask-image 속성 사용 (Data URI)\n\n장점: HTTP 요청 감소 (data URI 사용 시), CSS 스타일링 용이, JS 번들 크기 감소 가능성\n단점: data URI 인코딩 필요, 복잡한 SVG 내부 스타일링 제한, 브라우저 지원 고려 필요\n\n3. SVG 스프라이트 방식 (&lt;use&gt; 태그로 스프라이트 참조):\n\n장점: 한 번의 HTTP 요청, 동적 CSS 스타일링 가능, 브라우저 캐싱, JS 번들 크기에 영향 미미.\n단점: 스프라이트 파일 생성 및 관리 어려움, 레이어 처리 복잡\n\n리서치 노트: avoid-svg-in-js\n채택한 방식: SVG 스프라이트 방식\n이유\n현재 차용하고 있는 Next의 &lt;Image&gt; 컴포넌트 방식을 유지하면서 점직적으로 도입할수 있는 방식이라 생각했다.\n이미 &lt;Image&gt; src에 넣는 SVG 파일 path를 객체로 생성하는 스크립트를 만들어 사용중이여서, Sprite 파일 생성 스크립트를 추가하는것도 어렵지 않을 것 같았다.\n여러번의 고난?끝에 현재 asset 폴더구조를 이용해 icon과 image 모은 스프라이트 파일 생성 하고 동적으로 css를 적용할수 있는 스크립트를 완성했다.\n기술 구현:\n\n속성을 개별적으로 추출하고 기본값을 설정\n\n// 각 SVG 요소에서 기존 스타일 속성 추출\n \nconst fillMatch = attributes.match(/\\sfill\\s*=\\s*[&#039;&quot;]([^&#039;&quot;]+)[&#039;&quot;]/)\nconst strokeMatch = attributes.match(/\\sstroke\\s*=\\s*[&#039;&quot;]([^&#039;&quot;]+)[&#039;&quot;]/)\nconst widthMatch = attributes.match(/\\swidth\\s*=\\s*[&#039;&quot;]([^&#039;&quot;]+)[&#039;&quot;]/)\nconst heightMatch = attributes.match(/\\sheight\\s*=\\s*[&#039;&quot;]([^&#039;&quot;]+)[&#039;&quot;]/)\n \n// 원본 값 저장 및 기본값 설정\n \nconst originalFill = fillMatch ? fillMatch[1] : null\nconst originalStroke = strokeMatch ? strokeMatch[1] : null\nconst originalWidth = widthMatch ? widthMatch[1] : &quot;24&quot;\nconst originalHeight = heightMatch ? heightMatch[1] : &quot;24&quot;\n\n기존 속성을 완전히 제거한 후 CSS 변수를 사용하여 동적 스타일링이 가능하도록 재구성\n\n// 먼저 기존 속성들을 깔끔하게 제거 (fill, stroke, width, height 제거)\n// viewport는 비율을 위해 유지\n \nattributes = attributes.replace(/\\sfill\\s*=\\s*[&#039;&quot;][^&#039;&quot;]+[&#039;&quot;]/gi, &quot;&quot;)\nattributes = attributes.replace(/\\sstroke\\s*=\\s*[&#039;&quot;][^&#039;&quot;]+[&#039;&quot;]/gi, &quot;&quot;)\nattributes = attributes.replace(/\\swidth\\s*=\\s*[&#039;&quot;][^&#039;&quot;]+[&#039;&quot;]/gi, &quot;&quot;)\nattributes = attributes.replace(/\\sheight\\s*=\\s*[&#039;&quot;][^&#039;&quot;]+[&#039;&quot;]/gi, &quot;&quot;)\n \n// 그 다음 CSS 변수와 함께 재구성\nlet modifiedTag = `&lt;${tag} ${attributes.trim()}`\nif (originalFill) modifiedTag += ` fill=&quot;var(--${tag}-fill, ${originalFill})&quot;`\n \nif (originalStroke) modifiedTag += ` stroke=&quot;var(--${tag}-stroke, ${originalStroke})&quot;`\n\n크기 조절 용이하게 고정 크기 제거\n\n// 아이콘 SVG 파일에서 고정 크기 속성 제거 - 동적 크기 조절을 위한 핵심 작업\n \nsvgContent = svgContent.replace(/&lt;svg[^&gt;]*\\swidth=&quot;[^&quot;]*&quot;/gi, &quot;&lt;svg&quot;)\nsvgContent = svgContent.replace(/&lt;svg[^&gt;]*\\sheight=&quot;[^&quot;]*&quot;/gi, &quot;&lt;svg&quot;)\n\n&lt;use&gt;를 사용하기 위해 &lt;svg&gt; 태그를 &lt;symbol&gt; 태그로 변환 및 각 파일 이름 기반 id 부여\n\n// 고유한 ID 생성 로직\nconst fileNameWithoutExt = path.basename(file, path.extname(file))\nconst symbolId = createIdName(fileNameWithoutExt)\n \n// SVG를 Symbol로 변환\nsvgContent = svgContent\n  .replace(&quot;&lt;svg&quot;, `&lt;symbol id=&quot;${symbolId}&quot;`)\n  .replace(&quot;&lt;/svg&gt;&quot;, &quot;&lt;/symbol&gt;&quot;)\n  .replace(/\\s?xmlns=&quot;http:\\/\\/www\\.w3\\.org\\/2000\\/svg&quot;/g, &quot;&quot;)\n변환 전\n&lt;svg xmlns=&quot;www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot;&gt;\n  &lt;path fill=&quot;#000000&quot; d=&quot;M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z&quot; /&gt;\n&lt;/svg&gt;\n변환 후\n \n&lt;svg xmlns=&quot;www.w3.org/2000/svg&quot;&gt;\n  &lt;symbol id=&quot;ic_arrowDown&quot; viewBox=&quot;0 0 24 24&quot;&gt;\n    &lt;path fill=&quot;var(--path-fill, #000000)&quot; width=&quot;var(--path-width, 24)&quot; height=&quot;var(--path-height, 24)&quot; d=&quot;M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z&quot;/&gt;\n  &lt;/symbol&gt;\n  &lt;!-- 다른 심볼들 --&gt;\n&lt;/svg&gt;\n \n \nSVG &lt;use&gt;를 활용한 컴포넌트 추상화.\nimport cn from &quot;@/utils/clsx&quot;\n \nexport default function Svg({\n  name,\n  width = &quot;24&quot;,\n  height,\n  type = &quot;icon&quot;,\n  className,\n  addName = &quot;&quot;,\n  style,\n}) {\n  const calculatedHeight = height || width\n  const prefix = type === &quot;icon&quot; ? &quot;ic&quot; : &quot;img&quot;\n \n  return (\n    &lt;svg\n      width={width}\n      height={calculatedHeight}\n      className={cn(&quot;Svg&quot;, className)}\n      aria-label={name}\n      style={style}\n    &gt;\n      &lt;use href={`/assets/${type}s_sprite.svg/#${prefix}_${name}`} className={cn(name)} /&gt;\n \n      {addName &amp;&amp; (\n        &lt;use href={`/assets/${type}s_sprite.svg/#${prefix}_${addName}`} className={cn(addName)} /&gt;\n      )}\n    &lt;/svg&gt;\n  )\n}\n활용예시: 피드백 폼에서의 동적 색상 변경\n컴포넌트가 조건에 따라 비활성화 상태일때의 색과 활성화 될때의 색 동적으로 표시\n// 컴포넌트.js\n&lt;Svg name=&quot;chatBubbles&quot; className={cn(styles.chatIcon, { [styles.disabled]: disabled })} /&gt;\n// 컴포넌트.module.css\n \n.disabled {\n  --path-fill: var(--grey-50); /* 비활성화 상태: 연한 회색 경로 */\n  --circle-fill: var(--grey-300); /* 비활성화 상태: 중간 회색 원 */\n}\n레이어\n한 블로그 Complete guide to SVG sprites에서 sprite내에서 symbol들을 더 잘게 레이어로 쪼개 재사용하는 법을 읽었다.\n아이콘 자체로 재사용 하려했지 아이콘 내의 요소들을 또 나눠서 그걸 기반으로 또 사용할 생각을 못했었다.\n버튼이 이렇게 비활성화 / 활성화 적용이 되어야 하는데 디자인대로 구현시 안의 화살표와 밖의 원을 서로 다른 색상을 적용을 시켜줘야 되어야했다.\n\n\n그래서 수동으로 원부분과 화살표 아이콘을 따로 svg 파일로 분리해서 sprite에 넣고 컴포넌트에서 조합을 하였다.\n레이어를 쌓아 구현하기 위해 &lt;Svg&gt; 컴포넌트를 svg를 한개 더 참조할수 있게 addName props를 추가했다\n// props로 두번째 아이콘을 받으면 생성\n{addName &amp;&amp;}\n디자인 일관성을 위해 아이콘 디자인 내에서 사용되는 요소들이 많아서 figma에서 다 분해후 정리해서 이렇게 레이어 처럼 쓰는것도 괜찮겠다 생각했다. 근데 품이 많이 들고 새 아이콘이 추가될때마다 개발자가 일일히 조합해서 사용하는것 또한 조금은 최적화 되는 성능에 비해 미친짓일지도…\n프로젝트 내 활용 예시: 피드백 폼에서의 동적 색상 변경\n// FeedbackForm.jsx\nexport default function FeedbackForm({ id }) {\n  // ... 다른 코드 생략 ...\n \n        &lt;button className={s.submitButton} type=&quot;submit&quot; disabled={!isValid}&gt;\n          &lt;Svg\n            addName=&quot;arrowDown&quot;  // 첫 번째 아이콘 - 화살표\n            name=&quot;circle&quot;        // 두 번째 아이콘 - 원\n            className=&quot;arrowCircle&quot;\n            width=&quot;40&quot;\n          /&gt;\n        &lt;/button&gt;\n \n  // ... 다른 코드 생략 ...\n  );\n}\nCSS로 동적 색상 적용:\n/* FeedbackForm.module.css */\n.submitButton :global(.arrowCircle .circle) {\n  width: 40px;\n  height: 40px;\n  --circle-fill: var(--brand-black); /* 기본 상태: 검은색 원 */\n}\n \n.submitButton :global(.arrowCircle .arrowDown) {\n  --path-fill: var(--brand-yellow); /* 기본 상태: 노란색 화살표 */\n  transform: scale(0.6);\n  transform-origin: center;\n}\n \n.submitButton:disabled :global(.arrowCircle .circle) {\n  --circle-fill: var(--grey-100); /* 비활성화 상태: 회색 원 */\n}\n \n.submitButton:disabled :global(.arrowCircle .arrowDown) {\n  --path-fill: var(--grey-50); /* 비활성화 상태: 연한 회색 화살표 */\n}\n결과 및 성과\n이 SVG 스프라이트 시스템으로 얻은 주요 이점은:\n1. CSS 변수를 통한 동적 스타일링\n\n컴포넌트 상태에 따라 아이콘 색상 동적 변경 가능하다\n호버, 포커스, 비활성화 등 다양한 상태 대응 가능하다\n테마 변경에도 유연하게 대응할 수 있다\n\n2. 일관된 아이콘 시스템\n\n단일 &lt;Svg&gt; 컴포넌트로 모든 아이콘 관리한다\nname 속성만으로 간단하게 아이콘 변경 가능하다\n크기, 색상 등 속성을 일관되게 제어할 수 있다\n\n3. 성능 최적화\n\n스프라이트 방식으로 HTTP 요청 최소화된다\nJS 번들에 SVG 코드가 포함되지 않는다\n브라우저 캐싱 효율 극대화된다\n\n처음에는 단순한 최적화 작업이라고 생각했지만, 결국 사용자 경험과 개발 경험 모두를 크게 향상시키는 프로젝트가 되었다. 단순히 “아이콘을 사용”하는 것에서 “성능과 사용성을 모두 고려한 아이콘 시스템 구축”으로 접근 방식을 바꾸게 되었다.\n기술적 성과 및 배운 점\n\n웹 성능 최적화: JavaScript 번들 크기, 파싱/컴파일 시간, 메모리 사용량 등 다양한 측면에서의 성능 최적화 기법 습득\n문제 해결 능력: 성능 문제 식별, 대안 리서치, 솔루션 설계 및 구현의 전체 주기 경험\n시스템 설계: 확장 가능하고 유지보수하기 쉬운 아이콘 시스템 설계\n점진적 마이그레이션: 기존 코드베이스를 유지하면서 새로운 패턴을 도입하는 전략 수립\n\n단순한 이미지 최적화를 넘어, 웹 애플리케이션의 전체적인 성능과 사용자 경험을 고려한 종합적인 문제 해결을 하면서 많이 배울수 있었다.\n\n webpack\n\n개발 여정\n\n🌱 초기 아이디어: SVG-in-JS 피해야 하는 이유\n\n참고자료\n\nBreaking Up with SVG-in-JS in 2023 (2023) by Extrem, K. - Kurt Extrem의 SVG-in-JS 문제점 및 대안 분석\n2023년 SVG-in-JS와 결별 - Kurt Extrem 글의 한국어 번역\nWhich SVG technique performs best for way too many icons? (2021) by Stika, T.\n다양한 SVG 기법의 성능 비교 테스트\nIntroducing @svg-use (2024) - SVG 스프라이트를 React에서 쉽게 사용할 수 있는 새로운 라이브러리 소개\nSVG Sprite 기법을 사용해 나만의 특별한 Icon 컴포넌트 개발 (2023) - SVG 스프라이트를 활용한 React 컴포넌트 구현 사례\n아이콘으로 SVG 스프라이트를 만드는 방법(2023) - SVG 스프라이트 생성 방법론\n"},"Projects/index":{"slug":"Projects/index","filePath":"Projects/_index.md","title":"Projects","links":[],"tags":[],"content":"프로젝트 🚀\nDocumentation and retrospectives for my projects."},"Projects/viewMyStartup/retrospective":{"slug":"Projects/viewMyStartup/retrospective","filePath":"Projects/viewMyStartup/retrospective.md","title":"개발 문제 해결 과정","links":["view-my-startup-회고"],"tags":["retrospective","KPT"],"content":"첫 팀 프로젝트 회고록 (View My Startup)\n문제점 단위로 3주간 노트했던것을 정리해봤습니다. 개발적 이슈 외, 팀 협업에서 팀 소통과 본딩이 중요 하다는것을 다시 한번 깨달았습니다. 여러시각을 가진 사람들이 팀으로 같은 방향을 바라보고 같은 페이지에 있다는게 핵심이였던것 같습니다. 결과의 성취보다 과정에서 즐겁게 같이 배운다는 느낌이 가장 보람찼던 경험이였습니다.\nWeek 1 회고록\n회고록\n문제: BigInt Type 직렬화\n\n프로젝트 진행 중, BigInt 타입을 JSON으로 직렬화할 때 TypeError: Do not know how to serialize a BigInt라는 에러가 발생함.\nJavaScript에서 BigInt 타입을 JSON으로 변환할 때 발생하는 문제.\n\n해결책:\n\n\n옵션 1: 앱 시작 파일 (app.js)에서 BigInt를 문자열로 변환\njavascriptCopy code\nBigInt.prototype.toJSON = function () {\n  return { $bigint: this.toString() };\n};\n \nMDN: 참고 링크\n\n\n옵션 2: Prisma에서 BigInt 타입을 문자열로 변환하는 방법\njavascriptCopy code\nJSON.stringify(\n  this,\n  (key, value) =&gt; (typeof value === &#039;bigint&#039; ? value.toString() : value)\n);\n \nPrisma: 참고 링크\n\n\n다른 문제점:\n\nBigInt 값을 문자열로 먼저 변환하면 숫자로 정렬할 때 문제가 생김. 정렬 후에 문자열로 변환하여 응답을 보내는 방식으로 해결함.\n\n해결 방법:\n\n\n옵션 1: map을 사용하여 BigInt 타입에 toString() 적용\njavascriptCopy code\nconst bigIntToString = companies.map((company) =&gt; ({\n  ...company,\n  actualInvestment: company.actualInvestment.toString(),\n  revenue: company.revenue.toString(),\n}));\n \n\n\n옵션 2: JSON.stringify → JSON.parse 방식 사용\njavascriptCopy code\nfunction bigIntToString(data) {\n  return JSON.stringify(data, (key, value) =&gt; {\n    return typeof value === &quot;bigint&quot; ? value.toString() : value;\n  });\n}\n \nconst parsedResult = JSON.parse(bigIntToString(company));\nres.send(parsedResult);\n \n\n\n결과:\n\nJSON.stringify만 사용할 경우, 응답의 Content-Type이 text/html로 설정되는 문제가 있어 이를 다시 JSON.parse로 처리하여 문제를 해결함.\n하지만 두 번 연산하는 것이 비효율적이라고 판단하여, map을 사용하는 방법을 선택함.\nJSON.stringify를 사용하는 함수에서는 res.setHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);로 설정하여 parse를 사용하지 않아도 되도록 조정함.\n\n\n\n\n문제: 테이블의 내용 줄임 표시 (ellipsis)\n\n테이블에서 2줄 이상의 내용을 줄임 표시(...)로 나타내야 하는 문제 발생.\n\n해결책:\n\n\nCSS를 사용하여 줄임 표시를 구현함.\ncssCopy code .TableRow .description {\n  max-width: 301px;\n  width: 100%;\n}\n \n.TableRow .description span {\n  display: -webkit-box;\n  -webkit-box-orient: vertical;\n  -webkit-line-clamp: 2;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: normal;\n}\n\n\n결과:\n\n\nline-clamp를 사용하기 위해서는 블록 레벨 요소가 필요하므로, 이를 위해 td 내에 span으로 감싸서 문제를 해결함.\n\n\n추가 설정:이 두 가지 속성을 함께 사용하여 ellipsis를 정상적으로 적용함.\ncssCopy code\noverflow: hidden;\nwhite-space: nowrap;\n \n\n\n\n\n\n문제: 테이블의 첫 번째 컬럼이 타블렛 사이즈에서 display: none이 되며, border-radius도 사라짐\n\n타블렛 사이즈에서 테이블의 첫 번째 컬럼이 display: none으로 처리될 때, 테이블의 border-radius가 사라지는 문제 발생.\n\n해결책:\n\n\n테이블 thead와 tbody에 border-radius를 적용\ncssCopy code .Table thead tr th:first-child {\n  border-bottom-left-radius: 4px;\n}\n \n.Table thead tr th:last-child {\n  border-bottom-right-radius: 4px;\n}\n \n.Table tbody tr:first-child td:first-child {\n  border-top-left-radius: 4px;\n}\n \n.Table tbody tr:first-child td:last-child {\n  border-top-right-radius: 4px;\n}\n\n\n\n문제: Pagination 요구사항 불일치\n\n요구사항에서는 커서 기반 페이지네이션을 요구되었지만 디자인은 오프셋 기반으 최적화로 되어 있었음. 이로 인해 구현 방법에 대한 고민이 필요했음.\n\n해결책:\n\n토론 후 결론:\n\n오프셋 기반 페이지네이션으로 변경함. 커서 기반의 장점이 명확하지 않았고, 디자인과의 일관성을 유지하기 위해 이 방식을 선택함.\n만약 커서 기반을 유지할 경우, 미리 서버에서 5개 페이지 수만큼의 데이터를 조회해 커서 ID 배열을 제공해야 했기 때문에, 커서 기반의 메리트가 없다는 결론에 도달함.\n\n\n\n\n회고록 - Week 2\n이번 주에는 테이블, 드롭다운 버튼, 페이지네이션을 공통 컴포넌트로 만드는 작업을 진행했음. 작업 중 여러 문제에 직면했지만, 이를 해결하면서 많은 것을 배움.\n리스트로 하기보단 table이 . 더 시맨틱 했기 때문에 테이블로 공통 컴포넌트화 작업함.\n문제 1: 테이블 컴포넌트화의 어려움\n각 테이블마다 필요한 필드와 렌더링 방식이 달라 공통 컴포넌트로 구현하는 것이 까다로웠음.\n해결책:\n\n유연한 렌더링 방식 도입:필드 종류에 따라 유연하게 렌더링할 수 있도록 설계해 다양한 테이블 구조를 지원함.\nTable 컴포넌트:list와 tableHeaders를 받아 동적으로 테이블을 생성하도록 설계함. 데이터 유효성 검사를 통해 list 가 없거나 잘못된 형식의 데이터를 처리하고, tableHeaders를 기반으로 thead와 tbody를 생성함. 각 셀은 TableData 컴포넌트를 통해 필드별로 다른 스타일과 기능을 지원하도록 했음.\nTableData 컴포넌트:각 셀의 데이터를 렌더링하며, header와 item을 받아 필드에 따라 적절한 렌더링을 수행함. 예를 들어, 기업명 필드는 로고와 링크를 표시하고, 투자 금액 필드는 포맷 변환을 적용함.\nColGroup 컴포넌트:테이블 컬럼의 너비를 설정하는 역할을 함. columns를 받아 특정 필드는 고정 너비로, 나머지는 공통 너비로 설정해 일관된 레이아웃을 유지함.\n\n개선점:\n\nPropTypes를 활용해 타입 체크를 강화할 필요가 있음.\nReact-table 같은 라이브러리를 사용하는 것도 좋은 방법이라고 생각했음.\n\n문제 2: 드롭다운 버튼의 공통화\n드롭다운 버튼을 누를 때, 각 버튼에 맞는 정렬된 데이터를 API로부터 Fetch해야 했음. 이 과정에서 다양한 드롭다운 버튼이 존재하는데, 이들을 각각 공통 컴포넌트로 관리하면서도 각기 다른 동작을 수행하도록 구현하는 것이 도전이었음.\n해결책:\n\n드롭다운 버튼 컴포넌트화:\n테이블 컴포넌트에서 했던 것처럼, 필요한 3개의 버튼을 객체(value, label)로 정의하고, props로 버튼 타입(buttonType), 정렬 기준(orderBy), 정렬 상태 업데이트 함수(setOrderBy)를 받아 각 버튼이 고유의 동작을 수행하도록 설계함.\n\n정렬 상태 관리:sortBy와 order 두 가지 쿼리 파라미터를 orderBy라는 단일 상태로 관리함. 예를 들어, orderBy 상태를 &quot;sort-by_order&quot; 형식으로 업데이트하여, API 호출 시 이 값을 split하여 sortBy와 order로 분리해 사용하도록 함.\n\n\n\n문제 3: 페이지네이션에서 무한 루프 문제\n문제점:\n페이지네이션 구현 과정에서 부모 컴포넌트 함수에서 totalPages를 계산한 후 페이지네이션 컴포넌트에 내려줄 때 무한 루프 API 호출이 발생했음.\nqueryParams state에서 totalPages를 같이 관리하면서, 이 값이 변경될 때마다 init 함수가 다시 실행돼, API 호출이 반복되는 무한 루프 상황이 발생했음.\n해결책:\ntotalPages 값이 변경될 때만 상태를 업데이트하도록 조건문을 추가해 무한 루프 문제를 해결함. 새로운 totalPages 값을 기존 값과 비교해 다를 경우에만 상태를 업데이트하도록 함.\n\n문제 4: 가로 스크롤바 커스텀 디자인\n\n상황 설명:\n\n크롬에서는 커스텀 스크롤바 디자인이 잘 적용되었으나, 파이어폭스에서는 적용되지 않는 문제가 발생함.\n파이어폭스를 위한 CSS 코드(scrollbar-width 및 scrollbar-color)를 추가하였으나, 이로 인해 크롬의 스크롤바 디자인이 깨지는 현상이 발생.\n\n\n\n해결책:\n\n파이어폭스 전용 스타일링:\n\n파이어폭스의 경우 @supports를 사용하여 특정 CSS 속성 지원 여부를 확인한 뒤, 해당 속성을 적용함으로써 문제를 해결하려고 했으나, 크롬에서도 이 코드가 영향을 미치면서 디자인이 깨짐.\n\n\n대안:\n\n브라우저별로 별도의 CSS 파일을 로드하거나, 특정 클래스명을 사용하여 브라우저에 따라 다른 스타일을 적용하도록 수정.\n\n\n\n\n문제 5: Loader 애니메이션 만들기\n\n상황 설명:\n\n커스텀 훅을 사용하여 load, error, api call 함수를 생성하는 과정에서 어려움을 겪음. 이해하는데 시간이 많이 소요 되었음.\nCSS 애니메이션 구현 시, 로고의 i의 head 부분만 바운스되도록 애니메이션을 적용하려 했으나, 화면 너비가 바뀌면 원하는 위치에 정확히 맞추기 어려움.\n\n\n\n\n해결책:\n\ni의 head 부분 바운스 애니메이션:\n\nSVG에서 i의 head 부분을 지우고, 동일한 원형을 div로 만들어 애니메이션을 적용함.\ncalc() 함수를 사용하여 부모 요소의 절반을 기준으로 원형을 이동시킴으로써 화면 비율이 변경되어도 위치가 고정되도록 조정.\n\n\n\nleft: calc(50% - 75px);\n \ntop: calc(50% - 35px);\n\n문제 6: 브랜드 이미지가 없을 때 사용할 디폴트 UI 생성 (LogoImg 컴포넌트)\n\n상황: 브랜드 이미지가 없는 경우, 해당 브랜드를 대표할 UI를 생성해야 했음. 이를 위해, 배경색을 랜덤으로 생성하고 그 위에 브랜드 이니셜을 표시하는 방식을 고려함.\n문제: 배경색을 랜덤으로 생성할 때, 밝은 색상이 선택되면 이니셜 텍스트(하얀색)가 잘 보이지 않는 상황이 발생함.\n\n2. 초기 접근 방법:\n\n랜덤 색상 생성: 먼저, 랜덤으로 HEX 색상 코드를 생성하는 방법을 사용함. 이를 통해 다양한 배경색을 쉽게 구현할 수 있었음.\n\n참고 자료:\n\nRandom HEX Color Code Snippets\nGenerate Random HEX Color in JavaScript\n\n\n\n\nContrast Ratio 계산: 배경색이 밝을 때 텍스트의 가독성을 위해, Relative Luminance를 사용해 텍스트와 배경 사이의 대비를 계산함. Luminance 계산을 위해 HEX에서 RGB로 색상 생성하는것으로 바꿈\n\n기존 공식:\n\nL = 0.2126 * R + 0.7152 * G + 0.0722 * B\n이 공식을 사용하여 배경과 텍스트 색상의 밝기를 계산한 후, 대비 비율을 다음과 같이 구함: ContrastRatio=L2+0.05L1+0.05\nContrastRatio=L1+0.05L2+0.05Contrast Ratio = \\frac{L1 + 0.05}{L2 + 0.05}\n그러나, 이 방법이 실제 사용자 경험과 일치하지 않는 문제를 발견함. 포뮬라 이론상 W3 기준 4.5:1 대비 비율에 만족하지만, 실제로는 텍스트가 잘 보이지 않는 경우가 있었음. 알고보니 outdated된 포뮬라였음.\n\n\n\n\n\n3. 새로운 접근법:\n\n문제: 기존 Relative Luminance 기반 대비 계산 공식은 실제 사용자의 시각적 인지와 일치하지 않았음. 특히, 밝은 배경과 어두운 텍스트 조합에서 이러한 문제가 더 두드러졌음.\n새로운 접근법: 더 정확한 대비 계산을 위해 Advanced Perceptual Contrast Algorithm (APCA)를 써야 한다함\n\nAPCA:\n\n설명: APCA는 기존 대비 계산 방식과 달리, 글꼴 크기, 굵기, 색상 조합 등을 고려하여 더 현실적인 대비를 계산함.\n공식: APCA는 색상의 밝기를 지수 함수로 변환하여 더 정확한 대비를 계산하며, 텍스트 크기와 굵기에 따라 요구되는 대비 수준을 동적으로 조정함.\n참고 자료: APCA 설명 및 구현 (계산식)\n일단 여기서 이거 하나 구현하는데 함수를 너무 많이 사용하고 집착하는거 같아서 살짝 식음..(너무 복잡해서 사용에 부담느낌)\n\n\n\n\n\n4. 문제 해결 및 한계:\n\n최종 해결책:\n\n생각해보니 어차피 테이블이 재 랜더링 될때 무작위로 또 배경색이 부여되서 디자인 일관성이 사라짐.\n데이터베이스 수정: 이를 해결하기 위해, 팀 회의후 데이터베이스에 brandColor 필드를 추가하여, brandImage가 없는 경우 brandColor를 사용해서 디폴트 로고를 만들기로 함.\nbrandColor enum(6종류의 색상)으로 mockup seeding 할때 랜덤으로 색상 넣어줌.\nContrast Ratio 확인: 어도비 색상대비 툴 사용해 주어진 배경색상에 최소 8:1의 대비를 되는 색상을 골라 프론트에서 텍스트 색상을 매칭해줌.\n\n\n\n5. 개선점 및 향후 계획:\n\n해쉬 함수 사용: 해쉬 함수를 사용하여 입력값에 따라 일관된 배경색을 생성하는 방법을 추천받음. 이렇게 하면 백엔드 수정 없이도 일관된 배경색을 유지할 수 있다함.\n\n개선및 하고싶은점: 연습으로, APCA 포뮬라를 사용해 랜덤 배경색을 지정하고, 그 배경색과 대비되는 텍스트 색상을 부여하는 기능을 구현해보고 싶음. 원래는 배경색의 베이스 컬러가 섞인 대비되는 텍스트 색상을 자동으로 생성하고 싶음.\n\n\n\n프로젝트 회고 마무리\n이번 프로젝트를 통해 백엔드와 프론트엔드 영역에서 모두 의미 있는 성장을 경험할 수 있었다.\n백엔드 개발\n백엔드 작업에서는 이전에 학습한 CRUD 기능을 실제로 적용하며 지식을 공고히 할 수 있었고 특히 페이지네이션 구현 과정에서 offset 기반과 cursor 기반 디자인의 차이점과 각각의 적합한 사용 상황에 대한 이해도를 높일 수 있었다. 이론적으로만 알고 있던 내용을 실제 프로젝트에 적용해보며 더욱 깊이 이해할수 있었다.\n프론트엔드 개발\n프론트엔드 개발에서는 공통 컴포넌트화 작업에 많은 시간과 노력을 했다. 이 과정에서 가장 중요했던 고민은 “컴포넌트의 자율성과 유연성의 균형”이었다. 어느 수준까지의 기능을 컴포넌트 내부에 포함시킬지, 그리고 어떤 부분을 외부에서 제어할 수 있도록 설계할지에 대한 깊은 고민을 통해 재사용성과 유지보수성이 높은 컴포넌트를 개발할 수 있었다.\n배운 점\n이번 프로젝트를 하면서 모듈화와 재사용 가능한 로직이 얼마나 중요한지 뼈저리게 느꼈다. 처음에는 급한 마음에 기능 구현에만 집중했는데, 나중에 코드를 정리하고 컴포넌트를 분리하면서 이게 얼마나 시간을 절약해주는지 직접 체감했다.\n특히 공통 컴포넌트를 만들 때는 다른 개발자들도 사용할 거라는 생각으로 좀 더 신경 썼다. “이 코드를 처음 보는 사람이 이해할 수 있을까?”라는 질문을 계속 던지면서 주석도 꼼꼼히 달고, 함수명도 더 직관적으로 짓기 위해 노력했다. 물론 어떤 사람들은 주석이 많은 코드가 나쁜 코드라고 하지만… 완벽한 코드를 짤 수 있을 때까지는 설명이 필요하다고 생각한다. 나도 아직 배울 게 많으니까.\n이번에 얻은 경험을 바탕으로 앞으로는 처음부터 구조를 좀 더 체계적으로 잡고 시작해야겠다. 나중에 리팩토링하는 것보다 처음부터 잘 설계하는 게 결국 더 빠르다는 걸 몸소 깨달았다. 다음 프로젝트에서는 더 효율적이고 유지보수하기 좋은 코드를 위해 초반 설계에 더 많은 시간을 투자해야겠다.\n관련 노트\n\nview my startup 회고\n"},"index":{"slug":"index","filePath":"_index.md","title":"Dev Garden","links":["My-Garden","Projects","Books"],"tags":[],"content":"Welcome to Amber’s Dev-garden 🌱🌿🌳 \nBlog가 아닌 Digital Garden으로 완벽이란 부담을 내려놓고 성장하는 글을 쓰는 곳입니다.\n초안 부터 완성 까지 모든 단계의 글을 적습니다. \n정원 둘러보기\n🌱 디지털 정원\n씨앗부터 나무까지, 작은 질문 부터 확장시켜 자유롭게 주제별로 연결하고 저만의 지식 네트워트를 쌓는 공간입니다.\n\n🌱 씨앗 단계: 새로운 아이디어와 질문들\n🌿 성장 단계: 발전하는 생각들\n🌳 완성 단계: 체계화된 지식\n\n🚀 프로젝트\n프로젝트 문서와 회고록을 모아둔 공간입니다.\n\n진행 중인 프로젝트\n프로젝트 회고\n기술 문서\n\n📚 독서 노트\n책을 통해 배운 내용을 정리하는 공간입니다.\n\n책 요약\n주요 인사이트\n실천 아이디어\n"}}