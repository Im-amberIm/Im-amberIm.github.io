---
title: 시간복잡도(Time Complexity)와 공간복잡도(Space Complexity)
description: 
stage: seedling
date: 2025-03-25
lastmod: 2025-03-25
tags:
  - seedling
category: 
enableToc: true
type: note
imageNameKey: Seedlings
draft: true
resource:
---

> 배경

## 🔍 Research

## 📊 **알고리즘 복잡도 핵심 정리** (초보자용 3단계 설명)

## 1️⃣ **왜 복잡도 분석이 필요할까?**

컴퓨터 성능이 천차만질 때 **"이 알고리즘이 얼마나 효율적이냐?"**를 객관적으로 비교하기 위한 **공통 언어**가 필요합니다.  
→ 예) "10초 걸린다"는 말보다 **"데이터 2배 증가시 4배 느려진다"**가 더 유용!

## 2️⃣ **Big-O의 본질** (핵심 원리)

![]([https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XDqI62zl](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XDqI62zl) 크기(N)가 무한대로 커질 때 가장 지배적인 성장 요소만 남긴다"**  
→ 상수(5, 100), 낮은 차수(n, log n)는 버림 (예: 3n² + 100n → **O(n²)**)

## 3️⃣ **각 복잡도별 특징** (실생활 예시로 이해하기)

## 🚀 **O(1)**: 즉시 완료

- **예시**: 책장에서 5번째 책 찾기
    
- **특징**: 입력 크기와 무관
    
```js

arr[4] // 배열의 5번째 요소 접근

```

## 📈 **O(log n)**: 점점 속도 감소

- **예시**: 전화번호부 반씩 찢어가며 이름 찾기
    
- **데이터 2배 증가시**: 단 1단계만 더 필요 (log₂2N = 1 + log₂N)
    
```js

binarySearch(sortedArr, target) // 이진 검색

```

## 🚗 **O(n)**: 정비례 증가

- **예시**: 책장 모든 책 제목 읽기
    
- **데이터 2배 증가시**: 시간도 2배 소요
    
```js

for (let i=0; i<arr.length; i++) { ... } // 단순 반복문


```

## ✈️ **O(n log n)**: 효율적인 정렬

- **예시**: 책을 가나다 순으로 정렬
    
- **대표 알고리즘**: 퀵소트, 머지소트
    

```js

arr.sort() // 대부분 언어의 내장 정렬


```

## 💥 **O(n²)**: 폭발적 증가

- **예시**: 모든 사람과 악수하기
    
- **데이터 2배 증가시**: 시간 4배 소요
    

```js

for (let i=0; i<n; i++) {   // 이중 반복문
  for (let j=0; j<n; j++) { ... }
}


```
## ☢️ **O(2ⁿ)**: 재앙적 성능

- **예시**: 암호 브루트포스 공격
    
- **데이터 10→20 증가시**: 1024배 느려짐
    

```js

function fibonacci(n) { // 재귀적 피보나치
  if(n <= 1) return n;
  return fibonacci(n-1) + fibonacci(n-2);
}


```
## 🔍 **공간 복잡도 추가 설명**

- **O(n)**: n크기 배열 생성 → 메모리도 n만큼 필요
    
- **O(1)**: 변수 몇 개만 사용 → 메모리 고정
    
- **재귀 호출**: 호출 스택이 쌓이므로 주의 필요!
    

## ❓ **왜 log의 밑은 무시하나요?**

수학적으로 **log₂N = log₁₀N / log₁₀2** → 상수배 차이라서 Big-O에서 무시합니다.  
→ 모든 로그는 결국 **같은 증가율 카테고리**로 분류됨

## 💡 **체감 팁**

- **O(n²) vs O(n log n)**  
    n=1,000일 때 → 1,000,000 vs 10,000 (100배 차이!)
    
- **O(2ⁿ)은 실용적이지 않음**  
    n=100일 때 → 1,267,650,600,228,229,401,496,703,205,376 연산 😱
    

**➡️ 실제 개발에서는 O(n²) 이상 복잡도는 가능한 피해야 합니다!**

### 🚩 알게된 것

-

### ⏭ 다음 단계 (What's Next?)

- [ ]

### 📚 References & Resources

### 📝 연관 노트

- 🌿 **Budding:** [[]]
- 🌳 **Evergreen:** [[]]
